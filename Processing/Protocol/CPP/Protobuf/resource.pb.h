// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Protobuf/resource.proto

#ifndef PROTOBUF_Protobuf_2fresource_2eproto__INCLUDED
#define PROTOBUF_Protobuf_2fresource_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "google/protobuf/csharp_options.pb.h"
// @@protoc_insertion_point(includes)

namespace resource {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Protobuf_2fresource_2eproto();
void protobuf_AssignDesc_Protobuf_2fresource_2eproto();
void protobuf_ShutdownFile_Protobuf_2fresource_2eproto();

class StoredMatrix;
class Raw;
class CompiledShader;
class ModelElement;
class ModelMaterial;
class Model;
class ModelGroup;
class StageProperty;
class StageCamera;
class StageLight;
class StageModel;
class Stage;
class Script;
class CsamlAttribute;
class CsamlNode;
class Csaml;
class UserInterface;

enum ModelMaterial_ModelMaterialType {
  ModelMaterial_ModelMaterialType_Blinn = 0
};
bool ModelMaterial_ModelMaterialType_IsValid(int value);
const ModelMaterial_ModelMaterialType ModelMaterial_ModelMaterialType_ModelMaterialType_MIN = ModelMaterial_ModelMaterialType_Blinn;
const ModelMaterial_ModelMaterialType ModelMaterial_ModelMaterialType_ModelMaterialType_MAX = ModelMaterial_ModelMaterialType_Blinn;
const int ModelMaterial_ModelMaterialType_ModelMaterialType_ARRAYSIZE = ModelMaterial_ModelMaterialType_ModelMaterialType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ModelMaterial_ModelMaterialType_descriptor();
inline const ::std::string& ModelMaterial_ModelMaterialType_Name(ModelMaterial_ModelMaterialType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ModelMaterial_ModelMaterialType_descriptor(), value);
}
inline bool ModelMaterial_ModelMaterialType_Parse(
    const ::std::string& name, ModelMaterial_ModelMaterialType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ModelMaterial_ModelMaterialType>(
    ModelMaterial_ModelMaterialType_descriptor(), name, value);
}
enum StageProperty_StagePropertyType {
  StageProperty_StagePropertyType_Unknown = 0,
  StageProperty_StagePropertyType_String = 1,
  StageProperty_StagePropertyType_Float = 2,
  StageProperty_StagePropertyType_Int = 3
};
bool StageProperty_StagePropertyType_IsValid(int value);
const StageProperty_StagePropertyType StageProperty_StagePropertyType_StagePropertyType_MIN = StageProperty_StagePropertyType_Unknown;
const StageProperty_StagePropertyType StageProperty_StagePropertyType_StagePropertyType_MAX = StageProperty_StagePropertyType_Int;
const int StageProperty_StagePropertyType_StagePropertyType_ARRAYSIZE = StageProperty_StagePropertyType_StagePropertyType_MAX + 1;

const ::google::protobuf::EnumDescriptor* StageProperty_StagePropertyType_descriptor();
inline const ::std::string& StageProperty_StagePropertyType_Name(StageProperty_StagePropertyType value) {
  return ::google::protobuf::internal::NameOfEnum(
    StageProperty_StagePropertyType_descriptor(), value);
}
inline bool StageProperty_StagePropertyType_Parse(
    const ::std::string& name, StageProperty_StagePropertyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StageProperty_StagePropertyType>(
    StageProperty_StagePropertyType_descriptor(), name, value);
}
enum StageLight_StageLightType {
  StageLight_StageLightType_Unknown = 0,
  StageLight_StageLightType_Spot = 1,
  StageLight_StageLightType_Directional = 2,
  StageLight_StageLightType_Point = 3
};
bool StageLight_StageLightType_IsValid(int value);
const StageLight_StageLightType StageLight_StageLightType_StageLightType_MIN = StageLight_StageLightType_Unknown;
const StageLight_StageLightType StageLight_StageLightType_StageLightType_MAX = StageLight_StageLightType_Point;
const int StageLight_StageLightType_StageLightType_ARRAYSIZE = StageLight_StageLightType_StageLightType_MAX + 1;

const ::google::protobuf::EnumDescriptor* StageLight_StageLightType_descriptor();
inline const ::std::string& StageLight_StageLightType_Name(StageLight_StageLightType value) {
  return ::google::protobuf::internal::NameOfEnum(
    StageLight_StageLightType_descriptor(), value);
}
inline bool StageLight_StageLightType_Parse(
    const ::std::string& name, StageLight_StageLightType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StageLight_StageLightType>(
    StageLight_StageLightType_descriptor(), name, value);
}
enum CsamlAttribute_CsamlAttributeType {
  CsamlAttribute_CsamlAttributeType_Unknown = 0,
  CsamlAttribute_CsamlAttributeType_ControlName = 1,
  CsamlAttribute_CsamlAttributeType_Width = 2,
  CsamlAttribute_CsamlAttributeType_Height = 3,
  CsamlAttribute_CsamlAttributeType_LayoutMode = 4,
  CsamlAttribute_CsamlAttributeType_Mode = 5,
  CsamlAttribute_CsamlAttributeType_Text = 6,
  CsamlAttribute_CsamlAttributeType_Source = 7,
  CsamlAttribute_CsamlAttributeType_TypeAttribute = 8,
  CsamlAttribute_CsamlAttributeType_Left = 9,
  CsamlAttribute_CsamlAttributeType_Top = 10,
  CsamlAttribute_CsamlAttributeType_Right = 11,
  CsamlAttribute_CsamlAttributeType_Bottom = 12,
  CsamlAttribute_CsamlAttributeType_HorizontalAlignment = 13,
  CsamlAttribute_CsamlAttributeType_VerticalAlignment = 14
};
bool CsamlAttribute_CsamlAttributeType_IsValid(int value);
const CsamlAttribute_CsamlAttributeType CsamlAttribute_CsamlAttributeType_CsamlAttributeType_MIN = CsamlAttribute_CsamlAttributeType_Unknown;
const CsamlAttribute_CsamlAttributeType CsamlAttribute_CsamlAttributeType_CsamlAttributeType_MAX = CsamlAttribute_CsamlAttributeType_VerticalAlignment;
const int CsamlAttribute_CsamlAttributeType_CsamlAttributeType_ARRAYSIZE = CsamlAttribute_CsamlAttributeType_CsamlAttributeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CsamlAttribute_CsamlAttributeType_descriptor();
inline const ::std::string& CsamlAttribute_CsamlAttributeType_Name(CsamlAttribute_CsamlAttributeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CsamlAttribute_CsamlAttributeType_descriptor(), value);
}
inline bool CsamlAttribute_CsamlAttributeType_Parse(
    const ::std::string& name, CsamlAttribute_CsamlAttributeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CsamlAttribute_CsamlAttributeType>(
    CsamlAttribute_CsamlAttributeType_descriptor(), name, value);
}
enum CsamlAttribute_CsamlAttributeValueType {
  CsamlAttribute_CsamlAttributeValueType_String = 0,
  CsamlAttribute_CsamlAttributeValueType_Int = 1,
  CsamlAttribute_CsamlAttributeValueType_Float = 2
};
bool CsamlAttribute_CsamlAttributeValueType_IsValid(int value);
const CsamlAttribute_CsamlAttributeValueType CsamlAttribute_CsamlAttributeValueType_CsamlAttributeValueType_MIN = CsamlAttribute_CsamlAttributeValueType_String;
const CsamlAttribute_CsamlAttributeValueType CsamlAttribute_CsamlAttributeValueType_CsamlAttributeValueType_MAX = CsamlAttribute_CsamlAttributeValueType_Float;
const int CsamlAttribute_CsamlAttributeValueType_CsamlAttributeValueType_ARRAYSIZE = CsamlAttribute_CsamlAttributeValueType_CsamlAttributeValueType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CsamlAttribute_CsamlAttributeValueType_descriptor();
inline const ::std::string& CsamlAttribute_CsamlAttributeValueType_Name(CsamlAttribute_CsamlAttributeValueType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CsamlAttribute_CsamlAttributeValueType_descriptor(), value);
}
inline bool CsamlAttribute_CsamlAttributeValueType_Parse(
    const ::std::string& name, CsamlAttribute_CsamlAttributeValueType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CsamlAttribute_CsamlAttributeValueType>(
    CsamlAttribute_CsamlAttributeValueType_descriptor(), name, value);
}
enum CsamlAttribute_CsamlLayoutMode {
  CsamlAttribute_CsamlLayoutMode_LayoutAbsolute = 0,
  CsamlAttribute_CsamlLayoutMode_LayoutRelative = 1
};
bool CsamlAttribute_CsamlLayoutMode_IsValid(int value);
const CsamlAttribute_CsamlLayoutMode CsamlAttribute_CsamlLayoutMode_CsamlLayoutMode_MIN = CsamlAttribute_CsamlLayoutMode_LayoutAbsolute;
const CsamlAttribute_CsamlLayoutMode CsamlAttribute_CsamlLayoutMode_CsamlLayoutMode_MAX = CsamlAttribute_CsamlLayoutMode_LayoutRelative;
const int CsamlAttribute_CsamlLayoutMode_CsamlLayoutMode_ARRAYSIZE = CsamlAttribute_CsamlLayoutMode_CsamlLayoutMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* CsamlAttribute_CsamlLayoutMode_descriptor();
inline const ::std::string& CsamlAttribute_CsamlLayoutMode_Name(CsamlAttribute_CsamlLayoutMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    CsamlAttribute_CsamlLayoutMode_descriptor(), value);
}
inline bool CsamlAttribute_CsamlLayoutMode_Parse(
    const ::std::string& name, CsamlAttribute_CsamlLayoutMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CsamlAttribute_CsamlLayoutMode>(
    CsamlAttribute_CsamlLayoutMode_descriptor(), name, value);
}
enum CsamlAttribute_CsamlControlSizingMode {
  CsamlAttribute_CsamlControlSizingMode_SizeNormal = 0,
  CsamlAttribute_CsamlControlSizingMode_SizeStretch = 1
};
bool CsamlAttribute_CsamlControlSizingMode_IsValid(int value);
const CsamlAttribute_CsamlControlSizingMode CsamlAttribute_CsamlControlSizingMode_CsamlControlSizingMode_MIN = CsamlAttribute_CsamlControlSizingMode_SizeNormal;
const CsamlAttribute_CsamlControlSizingMode CsamlAttribute_CsamlControlSizingMode_CsamlControlSizingMode_MAX = CsamlAttribute_CsamlControlSizingMode_SizeStretch;
const int CsamlAttribute_CsamlControlSizingMode_CsamlControlSizingMode_ARRAYSIZE = CsamlAttribute_CsamlControlSizingMode_CsamlControlSizingMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* CsamlAttribute_CsamlControlSizingMode_descriptor();
inline const ::std::string& CsamlAttribute_CsamlControlSizingMode_Name(CsamlAttribute_CsamlControlSizingMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    CsamlAttribute_CsamlControlSizingMode_descriptor(), value);
}
inline bool CsamlAttribute_CsamlControlSizingMode_Parse(
    const ::std::string& name, CsamlAttribute_CsamlControlSizingMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CsamlAttribute_CsamlControlSizingMode>(
    CsamlAttribute_CsamlControlSizingMode_descriptor(), name, value);
}
enum CsamlAttribute_CsamlHorizontalAlignmentEnum {
  CsamlAttribute_CsamlHorizontalAlignmentEnum_AlignLeft = 0,
  CsamlAttribute_CsamlHorizontalAlignmentEnum_AlignCenterH = 1,
  CsamlAttribute_CsamlHorizontalAlignmentEnum_AlignRight = 2
};
bool CsamlAttribute_CsamlHorizontalAlignmentEnum_IsValid(int value);
const CsamlAttribute_CsamlHorizontalAlignmentEnum CsamlAttribute_CsamlHorizontalAlignmentEnum_CsamlHorizontalAlignmentEnum_MIN = CsamlAttribute_CsamlHorizontalAlignmentEnum_AlignLeft;
const CsamlAttribute_CsamlHorizontalAlignmentEnum CsamlAttribute_CsamlHorizontalAlignmentEnum_CsamlHorizontalAlignmentEnum_MAX = CsamlAttribute_CsamlHorizontalAlignmentEnum_AlignRight;
const int CsamlAttribute_CsamlHorizontalAlignmentEnum_CsamlHorizontalAlignmentEnum_ARRAYSIZE = CsamlAttribute_CsamlHorizontalAlignmentEnum_CsamlHorizontalAlignmentEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* CsamlAttribute_CsamlHorizontalAlignmentEnum_descriptor();
inline const ::std::string& CsamlAttribute_CsamlHorizontalAlignmentEnum_Name(CsamlAttribute_CsamlHorizontalAlignmentEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    CsamlAttribute_CsamlHorizontalAlignmentEnum_descriptor(), value);
}
inline bool CsamlAttribute_CsamlHorizontalAlignmentEnum_Parse(
    const ::std::string& name, CsamlAttribute_CsamlHorizontalAlignmentEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CsamlAttribute_CsamlHorizontalAlignmentEnum>(
    CsamlAttribute_CsamlHorizontalAlignmentEnum_descriptor(), name, value);
}
enum CsamlAttribute_CsamlVerticalAlignmentEnum {
  CsamlAttribute_CsamlVerticalAlignmentEnum_AlignTop = 0,
  CsamlAttribute_CsamlVerticalAlignmentEnum_AlignCenterV = 1,
  CsamlAttribute_CsamlVerticalAlignmentEnum_AlignBottom = 2
};
bool CsamlAttribute_CsamlVerticalAlignmentEnum_IsValid(int value);
const CsamlAttribute_CsamlVerticalAlignmentEnum CsamlAttribute_CsamlVerticalAlignmentEnum_CsamlVerticalAlignmentEnum_MIN = CsamlAttribute_CsamlVerticalAlignmentEnum_AlignTop;
const CsamlAttribute_CsamlVerticalAlignmentEnum CsamlAttribute_CsamlVerticalAlignmentEnum_CsamlVerticalAlignmentEnum_MAX = CsamlAttribute_CsamlVerticalAlignmentEnum_AlignBottom;
const int CsamlAttribute_CsamlVerticalAlignmentEnum_CsamlVerticalAlignmentEnum_ARRAYSIZE = CsamlAttribute_CsamlVerticalAlignmentEnum_CsamlVerticalAlignmentEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* CsamlAttribute_CsamlVerticalAlignmentEnum_descriptor();
inline const ::std::string& CsamlAttribute_CsamlVerticalAlignmentEnum_Name(CsamlAttribute_CsamlVerticalAlignmentEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    CsamlAttribute_CsamlVerticalAlignmentEnum_descriptor(), value);
}
inline bool CsamlAttribute_CsamlVerticalAlignmentEnum_Parse(
    const ::std::string& name, CsamlAttribute_CsamlVerticalAlignmentEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CsamlAttribute_CsamlVerticalAlignmentEnum>(
    CsamlAttribute_CsamlVerticalAlignmentEnum_descriptor(), name, value);
}
enum CsamlNode_CsamlNodeType {
  CsamlNode_CsamlNodeType_Unknown = 0,
  CsamlNode_CsamlNodeType_Frame = 1,
  CsamlNode_CsamlNodeType_Image = 2,
  CsamlNode_CsamlNodeType_SolidText = 3,
  CsamlNode_CsamlNodeType_DynamicText = 4,
  CsamlNode_CsamlNodeType_Console = 5,
  CsamlNode_CsamlNodeType_Page = 6
};
bool CsamlNode_CsamlNodeType_IsValid(int value);
const CsamlNode_CsamlNodeType CsamlNode_CsamlNodeType_CsamlNodeType_MIN = CsamlNode_CsamlNodeType_Unknown;
const CsamlNode_CsamlNodeType CsamlNode_CsamlNodeType_CsamlNodeType_MAX = CsamlNode_CsamlNodeType_Page;
const int CsamlNode_CsamlNodeType_CsamlNodeType_ARRAYSIZE = CsamlNode_CsamlNodeType_CsamlNodeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CsamlNode_CsamlNodeType_descriptor();
inline const ::std::string& CsamlNode_CsamlNodeType_Name(CsamlNode_CsamlNodeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CsamlNode_CsamlNodeType_descriptor(), value);
}
inline bool CsamlNode_CsamlNodeType_Parse(
    const ::std::string& name, CsamlNode_CsamlNodeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CsamlNode_CsamlNodeType>(
    CsamlNode_CsamlNodeType_descriptor(), name, value);
}
// ===================================================================

class StoredMatrix : public ::google::protobuf::Message {
 public:
  StoredMatrix();
  virtual ~StoredMatrix();
  
  StoredMatrix(const StoredMatrix& from);
  
  inline StoredMatrix& operator=(const StoredMatrix& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StoredMatrix& default_instance();
  
  void Swap(StoredMatrix* other);
  
  // implements Message ----------------------------------------------
  
  StoredMatrix* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StoredMatrix& from);
  void MergeFrom(const StoredMatrix& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated float Data = 1;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline float data(int index) const;
  inline void set_data(int index, float value);
  inline void add_data(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      data() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_data();
  
  // @@protoc_insertion_point(class_scope:resource.StoredMatrix)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< float > data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Protobuf_2fresource_2eproto();
  friend void protobuf_AssignDesc_Protobuf_2fresource_2eproto();
  friend void protobuf_ShutdownFile_Protobuf_2fresource_2eproto();
  
  void InitAsDefaultInstance();
  static StoredMatrix* default_instance_;
};
// -------------------------------------------------------------------

class Raw : public ::google::protobuf::Message {
 public:
  Raw();
  virtual ~Raw();
  
  Raw(const Raw& from);
  
  inline Raw& operator=(const Raw& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Raw& default_instance();
  
  void Swap(Raw* other);
  
  // implements Message ----------------------------------------------
  
  Raw* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Raw& from);
  void MergeFrom(const Raw& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes Data = 1;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  
  // @@protoc_insertion_point(class_scope:resource.Raw)
 private:
  inline void set_has_data();
  inline void clear_has_data();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Protobuf_2fresource_2eproto();
  friend void protobuf_AssignDesc_Protobuf_2fresource_2eproto();
  friend void protobuf_ShutdownFile_Protobuf_2fresource_2eproto();
  
  void InitAsDefaultInstance();
  static Raw* default_instance_;
};
// -------------------------------------------------------------------

class CompiledShader : public ::google::protobuf::Message {
 public:
  CompiledShader();
  virtual ~CompiledShader();
  
  CompiledShader(const CompiledShader& from);
  
  inline CompiledShader& operator=(const CompiledShader& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CompiledShader& default_instance();
  
  void Swap(CompiledShader* other);
  
  // implements Message ----------------------------------------------
  
  CompiledShader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CompiledShader& from);
  void MergeFrom(const CompiledShader& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 Version = 1 [default = 1];
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);
  
  // required bytes MD5 = 2;
  inline bool has_md5() const;
  inline void clear_md5();
  static const int kMD5FieldNumber = 2;
  inline const ::std::string& md5() const;
  inline void set_md5(const ::std::string& value);
  inline void set_md5(const char* value);
  inline void set_md5(const void* value, size_t size);
  inline ::std::string* mutable_md5();
  inline ::std::string* release_md5();
  
  // required bytes Data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  
  // @@protoc_insertion_point(class_scope:resource.CompiledShader)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_md5();
  inline void clear_has_md5();
  inline void set_has_data();
  inline void clear_has_data();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* md5_;
  ::std::string* data_;
  ::google::protobuf::int32 version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Protobuf_2fresource_2eproto();
  friend void protobuf_AssignDesc_Protobuf_2fresource_2eproto();
  friend void protobuf_ShutdownFile_Protobuf_2fresource_2eproto();
  
  void InitAsDefaultInstance();
  static CompiledShader* default_instance_;
};
// -------------------------------------------------------------------

class ModelElement : public ::google::protobuf::Message {
 public:
  ModelElement();
  virtual ~ModelElement();
  
  ModelElement(const ModelElement& from);
  
  inline ModelElement& operator=(const ModelElement& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ModelElement& default_instance();
  
  void Swap(ModelElement* other);
  
  // implements Message ----------------------------------------------
  
  ModelElement* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModelElement& from);
  void MergeFrom(const ModelElement& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated float Position = 1 [packed = true];
  inline int position_size() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 1;
  inline float position(int index) const;
  inline void set_position(int index, float value);
  inline void add_position(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      position() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_position();
  
  // repeated float Normal = 2 [packed = true];
  inline int normal_size() const;
  inline void clear_normal();
  static const int kNormalFieldNumber = 2;
  inline float normal(int index) const;
  inline void set_normal(int index, float value);
  inline void add_normal(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      normal() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_normal();
  
  // repeated float Texture = 3 [packed = true];
  inline int texture_size() const;
  inline void clear_texture();
  static const int kTextureFieldNumber = 3;
  inline float texture(int index) const;
  inline void set_texture(int index, float value);
  inline void add_texture(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      texture() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_texture();
  
  // repeated float Tangent = 4 [packed = true];
  inline int tangent_size() const;
  inline void clear_tangent();
  static const int kTangentFieldNumber = 4;
  inline float tangent(int index) const;
  inline void set_tangent(int index, float value);
  inline void add_tangent(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      tangent() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_tangent();
  
  // @@protoc_insertion_point(class_scope:resource.ModelElement)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< float > position_;
  mutable int _position_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > normal_;
  mutable int _normal_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > texture_;
  mutable int _texture_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > tangent_;
  mutable int _tangent_cached_byte_size_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_Protobuf_2fresource_2eproto();
  friend void protobuf_AssignDesc_Protobuf_2fresource_2eproto();
  friend void protobuf_ShutdownFile_Protobuf_2fresource_2eproto();
  
  void InitAsDefaultInstance();
  static ModelElement* default_instance_;
};
// -------------------------------------------------------------------

class ModelMaterial : public ::google::protobuf::Message {
 public:
  ModelMaterial();
  virtual ~ModelMaterial();
  
  ModelMaterial(const ModelMaterial& from);
  
  inline ModelMaterial& operator=(const ModelMaterial& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ModelMaterial& default_instance();
  
  void Swap(ModelMaterial* other);
  
  // implements Message ----------------------------------------------
  
  ModelMaterial* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModelMaterial& from);
  void MergeFrom(const ModelMaterial& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef ModelMaterial_ModelMaterialType ModelMaterialType;
  static const ModelMaterialType Blinn = ModelMaterial_ModelMaterialType_Blinn;
  static inline bool ModelMaterialType_IsValid(int value) {
    return ModelMaterial_ModelMaterialType_IsValid(value);
  }
  static const ModelMaterialType ModelMaterialType_MIN =
    ModelMaterial_ModelMaterialType_ModelMaterialType_MIN;
  static const ModelMaterialType ModelMaterialType_MAX =
    ModelMaterial_ModelMaterialType_ModelMaterialType_MAX;
  static const int ModelMaterialType_ARRAYSIZE =
    ModelMaterial_ModelMaterialType_ModelMaterialType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ModelMaterialType_descriptor() {
    return ModelMaterial_ModelMaterialType_descriptor();
  }
  static inline const ::std::string& ModelMaterialType_Name(ModelMaterialType value) {
    return ModelMaterial_ModelMaterialType_Name(value);
  }
  static inline bool ModelMaterialType_Parse(const ::std::string& name,
      ModelMaterialType* value) {
    return ModelMaterial_ModelMaterialType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .resource.ModelMaterial.ModelMaterialType Type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::resource::ModelMaterial_ModelMaterialType type() const;
  inline void set_type(::resource::ModelMaterial_ModelMaterialType value);
  
  // required string Name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional string DiffuseTexture = 3;
  inline bool has_diffusetexture() const;
  inline void clear_diffusetexture();
  static const int kDiffuseTextureFieldNumber = 3;
  inline const ::std::string& diffusetexture() const;
  inline void set_diffusetexture(const ::std::string& value);
  inline void set_diffusetexture(const char* value);
  inline void set_diffusetexture(const char* value, size_t size);
  inline ::std::string* mutable_diffusetexture();
  inline ::std::string* release_diffusetexture();
  
  // optional string NormalTexture = 4;
  inline bool has_normaltexture() const;
  inline void clear_normaltexture();
  static const int kNormalTextureFieldNumber = 4;
  inline const ::std::string& normaltexture() const;
  inline void set_normaltexture(const ::std::string& value);
  inline void set_normaltexture(const char* value);
  inline void set_normaltexture(const char* value, size_t size);
  inline ::std::string* mutable_normaltexture();
  inline ::std::string* release_normaltexture();
  
  // optional string AlphaTexture = 5;
  inline bool has_alphatexture() const;
  inline void clear_alphatexture();
  static const int kAlphaTextureFieldNumber = 5;
  inline const ::std::string& alphatexture() const;
  inline void set_alphatexture(const ::std::string& value);
  inline void set_alphatexture(const char* value);
  inline void set_alphatexture(const char* value, size_t size);
  inline ::std::string* mutable_alphatexture();
  inline ::std::string* release_alphatexture();
  
  // optional string SpecularTexture = 6;
  inline bool has_speculartexture() const;
  inline void clear_speculartexture();
  static const int kSpecularTextureFieldNumber = 6;
  inline const ::std::string& speculartexture() const;
  inline void set_speculartexture(const ::std::string& value);
  inline void set_speculartexture(const char* value);
  inline void set_speculartexture(const char* value, size_t size);
  inline ::std::string* mutable_speculartexture();
  inline ::std::string* release_speculartexture();
  
  // required float Shinyness = 10;
  inline bool has_shinyness() const;
  inline void clear_shinyness();
  static const int kShinynessFieldNumber = 10;
  inline float shinyness() const;
  inline void set_shinyness(float value);
  
  // required float Refraction = 11;
  inline bool has_refraction() const;
  inline void clear_refraction();
  static const int kRefractionFieldNumber = 11;
  inline float refraction() const;
  inline void set_refraction(float value);
  
  // optional float Transparancy = 12;
  inline bool has_transparancy() const;
  inline void clear_transparancy();
  static const int kTransparancyFieldNumber = 12;
  inline float transparancy() const;
  inline void set_transparancy(float value);
  
  // repeated float ColorDiffuse = 20 [packed = true];
  inline int colordiffuse_size() const;
  inline void clear_colordiffuse();
  static const int kColorDiffuseFieldNumber = 20;
  inline float colordiffuse(int index) const;
  inline void set_colordiffuse(int index, float value);
  inline void add_colordiffuse(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      colordiffuse() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_colordiffuse();
  
  // repeated float ColorSpecular = 21 [packed = true];
  inline int colorspecular_size() const;
  inline void clear_colorspecular();
  static const int kColorSpecularFieldNumber = 21;
  inline float colorspecular(int index) const;
  inline void set_colorspecular(int index, float value);
  inline void add_colorspecular(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      colorspecular() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_colorspecular();
  
  // repeated float ColorEmission = 22 [packed = true];
  inline int coloremission_size() const;
  inline void clear_coloremission();
  static const int kColorEmissionFieldNumber = 22;
  inline float coloremission(int index) const;
  inline void set_coloremission(int index, float value);
  inline void add_coloremission(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      coloremission() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_coloremission();
  
  // repeated float ColorAmbient = 23 [packed = true];
  inline int colorambient_size() const;
  inline void clear_colorambient();
  static const int kColorAmbientFieldNumber = 23;
  inline float colorambient(int index) const;
  inline void set_colorambient(int index, float value);
  inline void add_colorambient(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      colorambient() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_colorambient();
  
  // @@protoc_insertion_point(class_scope:resource.ModelMaterial)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_diffusetexture();
  inline void clear_has_diffusetexture();
  inline void set_has_normaltexture();
  inline void clear_has_normaltexture();
  inline void set_has_alphatexture();
  inline void clear_has_alphatexture();
  inline void set_has_speculartexture();
  inline void clear_has_speculartexture();
  inline void set_has_shinyness();
  inline void clear_has_shinyness();
  inline void set_has_refraction();
  inline void clear_has_refraction();
  inline void set_has_transparancy();
  inline void clear_has_transparancy();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::std::string* diffusetexture_;
  ::std::string* normaltexture_;
  int type_;
  float shinyness_;
  ::std::string* alphatexture_;
  ::std::string* speculartexture_;
  float refraction_;
  float transparancy_;
  ::google::protobuf::RepeatedField< float > colordiffuse_;
  mutable int _colordiffuse_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > colorspecular_;
  mutable int _colorspecular_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > coloremission_;
  mutable int _coloremission_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > colorambient_;
  mutable int _colorambient_cached_byte_size_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];
  
  friend void  protobuf_AddDesc_Protobuf_2fresource_2eproto();
  friend void protobuf_AssignDesc_Protobuf_2fresource_2eproto();
  friend void protobuf_ShutdownFile_Protobuf_2fresource_2eproto();
  
  void InitAsDefaultInstance();
  static ModelMaterial* default_instance_;
};
// -------------------------------------------------------------------

class Model : public ::google::protobuf::Message {
 public:
  Model();
  virtual ~Model();
  
  Model(const Model& from);
  
  inline Model& operator=(const Model& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Model& default_instance();
  
  void Swap(Model* other);
  
  // implements Message ----------------------------------------------
  
  Model* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Model& from);
  void MergeFrom(const Model& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 Version = 1 [default = 1];
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);
  
  // required string Name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required bool TangentsCalculated = 3 [default = false];
  inline bool has_tangentscalculated() const;
  inline void clear_tangentscalculated();
  static const int kTangentsCalculatedFieldNumber = 3;
  inline bool tangentscalculated() const;
  inline void set_tangentscalculated(bool value);
  
  // repeated .resource.ModelElement Elements = 20;
  inline int elements_size() const;
  inline void clear_elements();
  static const int kElementsFieldNumber = 20;
  inline const ::resource::ModelElement& elements(int index) const;
  inline ::resource::ModelElement* mutable_elements(int index);
  inline ::resource::ModelElement* add_elements();
  inline const ::google::protobuf::RepeatedPtrField< ::resource::ModelElement >&
      elements() const;
  inline ::google::protobuf::RepeatedPtrField< ::resource::ModelElement >*
      mutable_elements();
  
  // repeated .resource.ModelMaterial Materials = 21;
  inline int materials_size() const;
  inline void clear_materials();
  static const int kMaterialsFieldNumber = 21;
  inline const ::resource::ModelMaterial& materials(int index) const;
  inline ::resource::ModelMaterial* mutable_materials(int index);
  inline ::resource::ModelMaterial* add_materials();
  inline const ::google::protobuf::RepeatedPtrField< ::resource::ModelMaterial >&
      materials() const;
  inline ::google::protobuf::RepeatedPtrField< ::resource::ModelMaterial >*
      mutable_materials();
  
  // repeated uint32 Indices = 22;
  inline int indices_size() const;
  inline void clear_indices();
  static const int kIndicesFieldNumber = 22;
  inline ::google::protobuf::uint32 indices(int index) const;
  inline void set_indices(int index, ::google::protobuf::uint32 value);
  inline void add_indices(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      indices() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_indices();
  
  // @@protoc_insertion_point(class_scope:resource.Model)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_tangentscalculated();
  inline void clear_has_tangentscalculated();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::int32 version_;
  bool tangentscalculated_;
  ::google::protobuf::RepeatedPtrField< ::resource::ModelElement > elements_;
  ::google::protobuf::RepeatedPtrField< ::resource::ModelMaterial > materials_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > indices_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_Protobuf_2fresource_2eproto();
  friend void protobuf_AssignDesc_Protobuf_2fresource_2eproto();
  friend void protobuf_ShutdownFile_Protobuf_2fresource_2eproto();
  
  void InitAsDefaultInstance();
  static Model* default_instance_;
};
// -------------------------------------------------------------------

class ModelGroup : public ::google::protobuf::Message {
 public:
  ModelGroup();
  virtual ~ModelGroup();
  
  ModelGroup(const ModelGroup& from);
  
  inline ModelGroup& operator=(const ModelGroup& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ModelGroup& default_instance();
  
  void Swap(ModelGroup* other);
  
  // implements Message ----------------------------------------------
  
  ModelGroup* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModelGroup& from);
  void MergeFrom(const ModelGroup& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 Version = 1 [default = 1];
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);
  
  // required string Name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // repeated float Offset = 10 [packed = true];
  inline int offset_size() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 10;
  inline float offset(int index) const;
  inline void set_offset(int index, float value);
  inline void add_offset(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      offset() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_offset();
  
  // repeated float Rotation = 11 [packed = true];
  inline int rotation_size() const;
  inline void clear_rotation();
  static const int kRotationFieldNumber = 11;
  inline float rotation(int index) const;
  inline void set_rotation(int index, float value);
  inline void add_rotation(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      rotation() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_rotation();
  
  // repeated float Scale = 12 [packed = true];
  inline int scale_size() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 12;
  inline float scale(int index) const;
  inline void set_scale(int index, float value);
  inline void add_scale(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      scale() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_scale();
  
  // repeated .resource.Model Models = 20;
  inline int models_size() const;
  inline void clear_models();
  static const int kModelsFieldNumber = 20;
  inline const ::resource::Model& models(int index) const;
  inline ::resource::Model* mutable_models(int index);
  inline ::resource::Model* add_models();
  inline const ::google::protobuf::RepeatedPtrField< ::resource::Model >&
      models() const;
  inline ::google::protobuf::RepeatedPtrField< ::resource::Model >*
      mutable_models();
  
  // repeated .resource.ModelGroup Groups = 21;
  inline int groups_size() const;
  inline void clear_groups();
  static const int kGroupsFieldNumber = 21;
  inline const ::resource::ModelGroup& groups(int index) const;
  inline ::resource::ModelGroup* mutable_groups(int index);
  inline ::resource::ModelGroup* add_groups();
  inline const ::google::protobuf::RepeatedPtrField< ::resource::ModelGroup >&
      groups() const;
  inline ::google::protobuf::RepeatedPtrField< ::resource::ModelGroup >*
      mutable_groups();
  
  // repeated .resource.StoredMatrix Transformations = 22;
  inline int transformations_size() const;
  inline void clear_transformations();
  static const int kTransformationsFieldNumber = 22;
  inline const ::resource::StoredMatrix& transformations(int index) const;
  inline ::resource::StoredMatrix* mutable_transformations(int index);
  inline ::resource::StoredMatrix* add_transformations();
  inline const ::google::protobuf::RepeatedPtrField< ::resource::StoredMatrix >&
      transformations() const;
  inline ::google::protobuf::RepeatedPtrField< ::resource::StoredMatrix >*
      mutable_transformations();
  
  // @@protoc_insertion_point(class_scope:resource.ModelGroup)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_name();
  inline void clear_has_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::RepeatedField< float > offset_;
  mutable int _offset_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > rotation_;
  mutable int _rotation_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > scale_;
  mutable int _scale_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::resource::Model > models_;
  ::google::protobuf::RepeatedPtrField< ::resource::ModelGroup > groups_;
  ::google::protobuf::RepeatedPtrField< ::resource::StoredMatrix > transformations_;
  ::google::protobuf::int32 version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_Protobuf_2fresource_2eproto();
  friend void protobuf_AssignDesc_Protobuf_2fresource_2eproto();
  friend void protobuf_ShutdownFile_Protobuf_2fresource_2eproto();
  
  void InitAsDefaultInstance();
  static ModelGroup* default_instance_;
};
// -------------------------------------------------------------------

class StageProperty : public ::google::protobuf::Message {
 public:
  StageProperty();
  virtual ~StageProperty();
  
  StageProperty(const StageProperty& from);
  
  inline StageProperty& operator=(const StageProperty& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StageProperty& default_instance();
  
  void Swap(StageProperty* other);
  
  // implements Message ----------------------------------------------
  
  StageProperty* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StageProperty& from);
  void MergeFrom(const StageProperty& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef StageProperty_StagePropertyType StagePropertyType;
  static const StagePropertyType Unknown = StageProperty_StagePropertyType_Unknown;
  static const StagePropertyType String = StageProperty_StagePropertyType_String;
  static const StagePropertyType Float = StageProperty_StagePropertyType_Float;
  static const StagePropertyType Int = StageProperty_StagePropertyType_Int;
  static inline bool StagePropertyType_IsValid(int value) {
    return StageProperty_StagePropertyType_IsValid(value);
  }
  static const StagePropertyType StagePropertyType_MIN =
    StageProperty_StagePropertyType_StagePropertyType_MIN;
  static const StagePropertyType StagePropertyType_MAX =
    StageProperty_StagePropertyType_StagePropertyType_MAX;
  static const int StagePropertyType_ARRAYSIZE =
    StageProperty_StagePropertyType_StagePropertyType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  StagePropertyType_descriptor() {
    return StageProperty_StagePropertyType_descriptor();
  }
  static inline const ::std::string& StagePropertyType_Name(StagePropertyType value) {
    return StageProperty_StagePropertyType_Name(value);
  }
  static inline bool StagePropertyType_Parse(const ::std::string& name,
      StagePropertyType* value) {
    return StageProperty_StagePropertyType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required string Id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // required .resource.StageProperty.StagePropertyType Type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::resource::StageProperty_StagePropertyType type() const;
  inline void set_type(::resource::StageProperty_StagePropertyType value);
  
  // required bytes Data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  
  // @@protoc_insertion_point(class_scope:resource.StageProperty)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_data();
  inline void clear_has_data();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* id_;
  ::std::string* data_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Protobuf_2fresource_2eproto();
  friend void protobuf_AssignDesc_Protobuf_2fresource_2eproto();
  friend void protobuf_ShutdownFile_Protobuf_2fresource_2eproto();
  
  void InitAsDefaultInstance();
  static StageProperty* default_instance_;
};
// -------------------------------------------------------------------

class StageCamera : public ::google::protobuf::Message {
 public:
  StageCamera();
  virtual ~StageCamera();
  
  StageCamera(const StageCamera& from);
  
  inline StageCamera& operator=(const StageCamera& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StageCamera& default_instance();
  
  void Swap(StageCamera* other);
  
  // implements Message ----------------------------------------------
  
  StageCamera* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StageCamera& from);
  void MergeFrom(const StageCamera& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string Id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // required float FieldOfView = 2;
  inline bool has_fieldofview() const;
  inline void clear_fieldofview();
  static const int kFieldOfViewFieldNumber = 2;
  inline float fieldofview() const;
  inline void set_fieldofview(float value);
  
  // optional int32 LayerFlags = 10;
  inline bool has_layerflags() const;
  inline void clear_layerflags();
  static const int kLayerFlagsFieldNumber = 10;
  inline ::google::protobuf::int32 layerflags() const;
  inline void set_layerflags(::google::protobuf::int32 value);
  
  // repeated .resource.StageProperty Properties = 11;
  inline int properties_size() const;
  inline void clear_properties();
  static const int kPropertiesFieldNumber = 11;
  inline const ::resource::StageProperty& properties(int index) const;
  inline ::resource::StageProperty* mutable_properties(int index);
  inline ::resource::StageProperty* add_properties();
  inline const ::google::protobuf::RepeatedPtrField< ::resource::StageProperty >&
      properties() const;
  inline ::google::protobuf::RepeatedPtrField< ::resource::StageProperty >*
      mutable_properties();
  
  // repeated float Position = 20 [packed = true];
  inline int position_size() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 20;
  inline float position(int index) const;
  inline void set_position(int index, float value);
  inline void add_position(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      position() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_position();
  
  // repeated float Rotation = 21 [packed = true];
  inline int rotation_size() const;
  inline void clear_rotation();
  static const int kRotationFieldNumber = 21;
  inline float rotation(int index) const;
  inline void set_rotation(int index, float value);
  inline void add_rotation(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      rotation() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_rotation();
  
  // @@protoc_insertion_point(class_scope:resource.StageCamera)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_fieldofview();
  inline void clear_has_fieldofview();
  inline void set_has_layerflags();
  inline void clear_has_layerflags();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* id_;
  float fieldofview_;
  ::google::protobuf::int32 layerflags_;
  ::google::protobuf::RepeatedPtrField< ::resource::StageProperty > properties_;
  ::google::protobuf::RepeatedField< float > position_;
  mutable int _position_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > rotation_;
  mutable int _rotation_cached_byte_size_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_Protobuf_2fresource_2eproto();
  friend void protobuf_AssignDesc_Protobuf_2fresource_2eproto();
  friend void protobuf_ShutdownFile_Protobuf_2fresource_2eproto();
  
  void InitAsDefaultInstance();
  static StageCamera* default_instance_;
};
// -------------------------------------------------------------------

class StageLight : public ::google::protobuf::Message {
 public:
  StageLight();
  virtual ~StageLight();
  
  StageLight(const StageLight& from);
  
  inline StageLight& operator=(const StageLight& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StageLight& default_instance();
  
  void Swap(StageLight* other);
  
  // implements Message ----------------------------------------------
  
  StageLight* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StageLight& from);
  void MergeFrom(const StageLight& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef StageLight_StageLightType StageLightType;
  static const StageLightType Unknown = StageLight_StageLightType_Unknown;
  static const StageLightType Spot = StageLight_StageLightType_Spot;
  static const StageLightType Directional = StageLight_StageLightType_Directional;
  static const StageLightType Point = StageLight_StageLightType_Point;
  static inline bool StageLightType_IsValid(int value) {
    return StageLight_StageLightType_IsValid(value);
  }
  static const StageLightType StageLightType_MIN =
    StageLight_StageLightType_StageLightType_MIN;
  static const StageLightType StageLightType_MAX =
    StageLight_StageLightType_StageLightType_MAX;
  static const int StageLightType_ARRAYSIZE =
    StageLight_StageLightType_StageLightType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  StageLightType_descriptor() {
    return StageLight_StageLightType_descriptor();
  }
  static inline const ::std::string& StageLightType_Name(StageLightType value) {
    return StageLight_StageLightType_Name(value);
  }
  static inline bool StageLightType_Parse(const ::std::string& name,
      StageLightType* value) {
    return StageLight_StageLightType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required string Id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // required .resource.StageLight.StageLightType Type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::resource::StageLight_StageLightType type() const;
  inline void set_type(::resource::StageLight_StageLightType value);
  
  // optional float Radius = 3;
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 3;
  inline float radius() const;
  inline void set_radius(float value);
  
  // optional float Intensity = 4;
  inline bool has_intensity() const;
  inline void clear_intensity();
  static const int kIntensityFieldNumber = 4;
  inline float intensity() const;
  inline void set_intensity(float value);
  
  // optional float AmbientIntensity = 5;
  inline bool has_ambientintensity() const;
  inline void clear_ambientintensity();
  static const int kAmbientIntensityFieldNumber = 5;
  inline float ambientintensity() const;
  inline void set_ambientintensity(float value);
  
  // optional float SpotSize = 6;
  inline bool has_spotsize() const;
  inline void clear_spotsize();
  static const int kSpotSizeFieldNumber = 6;
  inline float spotsize() const;
  inline void set_spotsize(float value);
  
  // optional float Angle = 7;
  inline bool has_angle() const;
  inline void clear_angle();
  static const int kAngleFieldNumber = 7;
  inline float angle() const;
  inline void set_angle(float value);
  
  // optional int32 LayerFlags = 10;
  inline bool has_layerflags() const;
  inline void clear_layerflags();
  static const int kLayerFlagsFieldNumber = 10;
  inline ::google::protobuf::int32 layerflags() const;
  inline void set_layerflags(::google::protobuf::int32 value);
  
  // repeated .resource.StageProperty Properties = 11;
  inline int properties_size() const;
  inline void clear_properties();
  static const int kPropertiesFieldNumber = 11;
  inline const ::resource::StageProperty& properties(int index) const;
  inline ::resource::StageProperty* mutable_properties(int index);
  inline ::resource::StageProperty* add_properties();
  inline const ::google::protobuf::RepeatedPtrField< ::resource::StageProperty >&
      properties() const;
  inline ::google::protobuf::RepeatedPtrField< ::resource::StageProperty >*
      mutable_properties();
  
  // repeated float Location = 20 [packed = true];
  inline int location_size() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 20;
  inline float location(int index) const;
  inline void set_location(int index, float value);
  inline void add_location(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      location() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_location();
  
  // repeated float Direction = 21 [packed = true];
  inline int direction_size() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 21;
  inline float direction(int index) const;
  inline void set_direction(int index, float value);
  inline void add_direction(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      direction() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_direction();
  
  // repeated float Color = 22 [packed = true];
  inline int color_size() const;
  inline void clear_color();
  static const int kColorFieldNumber = 22;
  inline float color(int index) const;
  inline void set_color(int index, float value);
  inline void add_color(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      color() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_color();
  
  // @@protoc_insertion_point(class_scope:resource.StageLight)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_radius();
  inline void clear_has_radius();
  inline void set_has_intensity();
  inline void clear_has_intensity();
  inline void set_has_ambientintensity();
  inline void clear_has_ambientintensity();
  inline void set_has_spotsize();
  inline void clear_has_spotsize();
  inline void set_has_angle();
  inline void clear_has_angle();
  inline void set_has_layerflags();
  inline void clear_has_layerflags();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* id_;
  int type_;
  float radius_;
  float intensity_;
  float ambientintensity_;
  float spotsize_;
  float angle_;
  ::google::protobuf::RepeatedPtrField< ::resource::StageProperty > properties_;
  ::google::protobuf::RepeatedField< float > location_;
  mutable int _location_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > direction_;
  mutable int _direction_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > color_;
  mutable int _color_cached_byte_size_;
  ::google::protobuf::int32 layerflags_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];
  
  friend void  protobuf_AddDesc_Protobuf_2fresource_2eproto();
  friend void protobuf_AssignDesc_Protobuf_2fresource_2eproto();
  friend void protobuf_ShutdownFile_Protobuf_2fresource_2eproto();
  
  void InitAsDefaultInstance();
  static StageLight* default_instance_;
};
// -------------------------------------------------------------------

class StageModel : public ::google::protobuf::Message {
 public:
  StageModel();
  virtual ~StageModel();
  
  StageModel(const StageModel& from);
  
  inline StageModel& operator=(const StageModel& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StageModel& default_instance();
  
  void Swap(StageModel* other);
  
  // implements Message ----------------------------------------------
  
  StageModel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StageModel& from);
  void MergeFrom(const StageModel& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string Id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // optional int32 ReferenceId = 2;
  inline bool has_referenceid() const;
  inline void clear_referenceid();
  static const int kReferenceIdFieldNumber = 2;
  inline ::google::protobuf::int32 referenceid() const;
  inline void set_referenceid(::google::protobuf::int32 value);
  
  // optional int32 LayerFlags = 10;
  inline bool has_layerflags() const;
  inline void clear_layerflags();
  static const int kLayerFlagsFieldNumber = 10;
  inline ::google::protobuf::int32 layerflags() const;
  inline void set_layerflags(::google::protobuf::int32 value);
  
  // repeated .resource.StageProperty Properties = 11;
  inline int properties_size() const;
  inline void clear_properties();
  static const int kPropertiesFieldNumber = 11;
  inline const ::resource::StageProperty& properties(int index) const;
  inline ::resource::StageProperty* mutable_properties(int index);
  inline ::resource::StageProperty* add_properties();
  inline const ::google::protobuf::RepeatedPtrField< ::resource::StageProperty >&
      properties() const;
  inline ::google::protobuf::RepeatedPtrField< ::resource::StageProperty >*
      mutable_properties();
  
  // repeated float Translation = 20 [packed = true];
  inline int translation_size() const;
  inline void clear_translation();
  static const int kTranslationFieldNumber = 20;
  inline float translation(int index) const;
  inline void set_translation(int index, float value);
  inline void add_translation(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      translation() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_translation();
  
  // repeated float Rotation = 21 [packed = true];
  inline int rotation_size() const;
  inline void clear_rotation();
  static const int kRotationFieldNumber = 21;
  inline float rotation(int index) const;
  inline void set_rotation(int index, float value);
  inline void add_rotation(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      rotation() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_rotation();
  
  // repeated float Scale = 22 [packed = true];
  inline int scale_size() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 22;
  inline float scale(int index) const;
  inline void set_scale(int index, float value);
  inline void add_scale(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      scale() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_scale();
  
  // repeated .resource.StageModel Children = 30;
  inline int children_size() const;
  inline void clear_children();
  static const int kChildrenFieldNumber = 30;
  inline const ::resource::StageModel& children(int index) const;
  inline ::resource::StageModel* mutable_children(int index);
  inline ::resource::StageModel* add_children();
  inline const ::google::protobuf::RepeatedPtrField< ::resource::StageModel >&
      children() const;
  inline ::google::protobuf::RepeatedPtrField< ::resource::StageModel >*
      mutable_children();
  
  // @@protoc_insertion_point(class_scope:resource.StageModel)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_referenceid();
  inline void clear_has_referenceid();
  inline void set_has_layerflags();
  inline void clear_has_layerflags();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* id_;
  ::google::protobuf::int32 referenceid_;
  ::google::protobuf::int32 layerflags_;
  ::google::protobuf::RepeatedPtrField< ::resource::StageProperty > properties_;
  ::google::protobuf::RepeatedField< float > translation_;
  mutable int _translation_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > rotation_;
  mutable int _rotation_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > scale_;
  mutable int _scale_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::resource::StageModel > children_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_Protobuf_2fresource_2eproto();
  friend void protobuf_AssignDesc_Protobuf_2fresource_2eproto();
  friend void protobuf_ShutdownFile_Protobuf_2fresource_2eproto();
  
  void InitAsDefaultInstance();
  static StageModel* default_instance_;
};
// -------------------------------------------------------------------

class Stage : public ::google::protobuf::Message {
 public:
  Stage();
  virtual ~Stage();
  
  Stage(const Stage& from);
  
  inline Stage& operator=(const Stage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Stage& default_instance();
  
  void Swap(Stage* other);
  
  // implements Message ----------------------------------------------
  
  Stage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Stage& from);
  void MergeFrom(const Stage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 Version = 1 [default = 1];
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);
  
  // repeated string References = 9;
  inline int references_size() const;
  inline void clear_references();
  static const int kReferencesFieldNumber = 9;
  inline const ::std::string& references(int index) const;
  inline ::std::string* mutable_references(int index);
  inline void set_references(int index, const ::std::string& value);
  inline void set_references(int index, const char* value);
  inline void set_references(int index, const char* value, size_t size);
  inline ::std::string* add_references();
  inline void add_references(const ::std::string& value);
  inline void add_references(const char* value);
  inline void add_references(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& references() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_references();
  
  // repeated .resource.StageCamera Cameras = 10;
  inline int cameras_size() const;
  inline void clear_cameras();
  static const int kCamerasFieldNumber = 10;
  inline const ::resource::StageCamera& cameras(int index) const;
  inline ::resource::StageCamera* mutable_cameras(int index);
  inline ::resource::StageCamera* add_cameras();
  inline const ::google::protobuf::RepeatedPtrField< ::resource::StageCamera >&
      cameras() const;
  inline ::google::protobuf::RepeatedPtrField< ::resource::StageCamera >*
      mutable_cameras();
  
  // repeated .resource.StageLight Lights = 11;
  inline int lights_size() const;
  inline void clear_lights();
  static const int kLightsFieldNumber = 11;
  inline const ::resource::StageLight& lights(int index) const;
  inline ::resource::StageLight* mutable_lights(int index);
  inline ::resource::StageLight* add_lights();
  inline const ::google::protobuf::RepeatedPtrField< ::resource::StageLight >&
      lights() const;
  inline ::google::protobuf::RepeatedPtrField< ::resource::StageLight >*
      mutable_lights();
  
  // repeated .resource.StageModel Models = 12;
  inline int models_size() const;
  inline void clear_models();
  static const int kModelsFieldNumber = 12;
  inline const ::resource::StageModel& models(int index) const;
  inline ::resource::StageModel* mutable_models(int index);
  inline ::resource::StageModel* add_models();
  inline const ::google::protobuf::RepeatedPtrField< ::resource::StageModel >&
      models() const;
  inline ::google::protobuf::RepeatedPtrField< ::resource::StageModel >*
      mutable_models();
  
  // @@protoc_insertion_point(class_scope:resource.Stage)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> references_;
  ::google::protobuf::RepeatedPtrField< ::resource::StageCamera > cameras_;
  ::google::protobuf::RepeatedPtrField< ::resource::StageLight > lights_;
  ::google::protobuf::RepeatedPtrField< ::resource::StageModel > models_;
  ::google::protobuf::int32 version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_Protobuf_2fresource_2eproto();
  friend void protobuf_AssignDesc_Protobuf_2fresource_2eproto();
  friend void protobuf_ShutdownFile_Protobuf_2fresource_2eproto();
  
  void InitAsDefaultInstance();
  static Stage* default_instance_;
};
// -------------------------------------------------------------------

class Script : public ::google::protobuf::Message {
 public:
  Script();
  virtual ~Script();
  
  Script(const Script& from);
  
  inline Script& operator=(const Script& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Script& default_instance();
  
  void Swap(Script* other);
  
  // implements Message ----------------------------------------------
  
  Script* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Script& from);
  void MergeFrom(const Script& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 Version = 1 [default = 1];
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);
  
  // required bytes ScriptData = 2;
  inline bool has_scriptdata() const;
  inline void clear_scriptdata();
  static const int kScriptDataFieldNumber = 2;
  inline const ::std::string& scriptdata() const;
  inline void set_scriptdata(const ::std::string& value);
  inline void set_scriptdata(const char* value);
  inline void set_scriptdata(const void* value, size_t size);
  inline ::std::string* mutable_scriptdata();
  inline ::std::string* release_scriptdata();
  
  // @@protoc_insertion_point(class_scope:resource.Script)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_scriptdata();
  inline void clear_has_scriptdata();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* scriptdata_;
  ::google::protobuf::int32 version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Protobuf_2fresource_2eproto();
  friend void protobuf_AssignDesc_Protobuf_2fresource_2eproto();
  friend void protobuf_ShutdownFile_Protobuf_2fresource_2eproto();
  
  void InitAsDefaultInstance();
  static Script* default_instance_;
};
// -------------------------------------------------------------------

class CsamlAttribute : public ::google::protobuf::Message {
 public:
  CsamlAttribute();
  virtual ~CsamlAttribute();
  
  CsamlAttribute(const CsamlAttribute& from);
  
  inline CsamlAttribute& operator=(const CsamlAttribute& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CsamlAttribute& default_instance();
  
  void Swap(CsamlAttribute* other);
  
  // implements Message ----------------------------------------------
  
  CsamlAttribute* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CsamlAttribute& from);
  void MergeFrom(const CsamlAttribute& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef CsamlAttribute_CsamlAttributeType CsamlAttributeType;
  static const CsamlAttributeType Unknown = CsamlAttribute_CsamlAttributeType_Unknown;
  static const CsamlAttributeType ControlName = CsamlAttribute_CsamlAttributeType_ControlName;
  static const CsamlAttributeType Width = CsamlAttribute_CsamlAttributeType_Width;
  static const CsamlAttributeType Height = CsamlAttribute_CsamlAttributeType_Height;
  static const CsamlAttributeType LayoutMode = CsamlAttribute_CsamlAttributeType_LayoutMode;
  static const CsamlAttributeType Mode = CsamlAttribute_CsamlAttributeType_Mode;
  static const CsamlAttributeType Text = CsamlAttribute_CsamlAttributeType_Text;
  static const CsamlAttributeType Source = CsamlAttribute_CsamlAttributeType_Source;
  static const CsamlAttributeType TypeAttribute = CsamlAttribute_CsamlAttributeType_TypeAttribute;
  static const CsamlAttributeType Left = CsamlAttribute_CsamlAttributeType_Left;
  static const CsamlAttributeType Top = CsamlAttribute_CsamlAttributeType_Top;
  static const CsamlAttributeType Right = CsamlAttribute_CsamlAttributeType_Right;
  static const CsamlAttributeType Bottom = CsamlAttribute_CsamlAttributeType_Bottom;
  static const CsamlAttributeType HorizontalAlignment = CsamlAttribute_CsamlAttributeType_HorizontalAlignment;
  static const CsamlAttributeType VerticalAlignment = CsamlAttribute_CsamlAttributeType_VerticalAlignment;
  static inline bool CsamlAttributeType_IsValid(int value) {
    return CsamlAttribute_CsamlAttributeType_IsValid(value);
  }
  static const CsamlAttributeType CsamlAttributeType_MIN =
    CsamlAttribute_CsamlAttributeType_CsamlAttributeType_MIN;
  static const CsamlAttributeType CsamlAttributeType_MAX =
    CsamlAttribute_CsamlAttributeType_CsamlAttributeType_MAX;
  static const int CsamlAttributeType_ARRAYSIZE =
    CsamlAttribute_CsamlAttributeType_CsamlAttributeType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CsamlAttributeType_descriptor() {
    return CsamlAttribute_CsamlAttributeType_descriptor();
  }
  static inline const ::std::string& CsamlAttributeType_Name(CsamlAttributeType value) {
    return CsamlAttribute_CsamlAttributeType_Name(value);
  }
  static inline bool CsamlAttributeType_Parse(const ::std::string& name,
      CsamlAttributeType* value) {
    return CsamlAttribute_CsamlAttributeType_Parse(name, value);
  }
  
  typedef CsamlAttribute_CsamlAttributeValueType CsamlAttributeValueType;
  static const CsamlAttributeValueType String = CsamlAttribute_CsamlAttributeValueType_String;
  static const CsamlAttributeValueType Int = CsamlAttribute_CsamlAttributeValueType_Int;
  static const CsamlAttributeValueType Float = CsamlAttribute_CsamlAttributeValueType_Float;
  static inline bool CsamlAttributeValueType_IsValid(int value) {
    return CsamlAttribute_CsamlAttributeValueType_IsValid(value);
  }
  static const CsamlAttributeValueType CsamlAttributeValueType_MIN =
    CsamlAttribute_CsamlAttributeValueType_CsamlAttributeValueType_MIN;
  static const CsamlAttributeValueType CsamlAttributeValueType_MAX =
    CsamlAttribute_CsamlAttributeValueType_CsamlAttributeValueType_MAX;
  static const int CsamlAttributeValueType_ARRAYSIZE =
    CsamlAttribute_CsamlAttributeValueType_CsamlAttributeValueType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CsamlAttributeValueType_descriptor() {
    return CsamlAttribute_CsamlAttributeValueType_descriptor();
  }
  static inline const ::std::string& CsamlAttributeValueType_Name(CsamlAttributeValueType value) {
    return CsamlAttribute_CsamlAttributeValueType_Name(value);
  }
  static inline bool CsamlAttributeValueType_Parse(const ::std::string& name,
      CsamlAttributeValueType* value) {
    return CsamlAttribute_CsamlAttributeValueType_Parse(name, value);
  }
  
  typedef CsamlAttribute_CsamlLayoutMode CsamlLayoutMode;
  static const CsamlLayoutMode LayoutAbsolute = CsamlAttribute_CsamlLayoutMode_LayoutAbsolute;
  static const CsamlLayoutMode LayoutRelative = CsamlAttribute_CsamlLayoutMode_LayoutRelative;
  static inline bool CsamlLayoutMode_IsValid(int value) {
    return CsamlAttribute_CsamlLayoutMode_IsValid(value);
  }
  static const CsamlLayoutMode CsamlLayoutMode_MIN =
    CsamlAttribute_CsamlLayoutMode_CsamlLayoutMode_MIN;
  static const CsamlLayoutMode CsamlLayoutMode_MAX =
    CsamlAttribute_CsamlLayoutMode_CsamlLayoutMode_MAX;
  static const int CsamlLayoutMode_ARRAYSIZE =
    CsamlAttribute_CsamlLayoutMode_CsamlLayoutMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CsamlLayoutMode_descriptor() {
    return CsamlAttribute_CsamlLayoutMode_descriptor();
  }
  static inline const ::std::string& CsamlLayoutMode_Name(CsamlLayoutMode value) {
    return CsamlAttribute_CsamlLayoutMode_Name(value);
  }
  static inline bool CsamlLayoutMode_Parse(const ::std::string& name,
      CsamlLayoutMode* value) {
    return CsamlAttribute_CsamlLayoutMode_Parse(name, value);
  }
  
  typedef CsamlAttribute_CsamlControlSizingMode CsamlControlSizingMode;
  static const CsamlControlSizingMode SizeNormal = CsamlAttribute_CsamlControlSizingMode_SizeNormal;
  static const CsamlControlSizingMode SizeStretch = CsamlAttribute_CsamlControlSizingMode_SizeStretch;
  static inline bool CsamlControlSizingMode_IsValid(int value) {
    return CsamlAttribute_CsamlControlSizingMode_IsValid(value);
  }
  static const CsamlControlSizingMode CsamlControlSizingMode_MIN =
    CsamlAttribute_CsamlControlSizingMode_CsamlControlSizingMode_MIN;
  static const CsamlControlSizingMode CsamlControlSizingMode_MAX =
    CsamlAttribute_CsamlControlSizingMode_CsamlControlSizingMode_MAX;
  static const int CsamlControlSizingMode_ARRAYSIZE =
    CsamlAttribute_CsamlControlSizingMode_CsamlControlSizingMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CsamlControlSizingMode_descriptor() {
    return CsamlAttribute_CsamlControlSizingMode_descriptor();
  }
  static inline const ::std::string& CsamlControlSizingMode_Name(CsamlControlSizingMode value) {
    return CsamlAttribute_CsamlControlSizingMode_Name(value);
  }
  static inline bool CsamlControlSizingMode_Parse(const ::std::string& name,
      CsamlControlSizingMode* value) {
    return CsamlAttribute_CsamlControlSizingMode_Parse(name, value);
  }
  
  typedef CsamlAttribute_CsamlHorizontalAlignmentEnum CsamlHorizontalAlignmentEnum;
  static const CsamlHorizontalAlignmentEnum AlignLeft = CsamlAttribute_CsamlHorizontalAlignmentEnum_AlignLeft;
  static const CsamlHorizontalAlignmentEnum AlignCenterH = CsamlAttribute_CsamlHorizontalAlignmentEnum_AlignCenterH;
  static const CsamlHorizontalAlignmentEnum AlignRight = CsamlAttribute_CsamlHorizontalAlignmentEnum_AlignRight;
  static inline bool CsamlHorizontalAlignmentEnum_IsValid(int value) {
    return CsamlAttribute_CsamlHorizontalAlignmentEnum_IsValid(value);
  }
  static const CsamlHorizontalAlignmentEnum CsamlHorizontalAlignmentEnum_MIN =
    CsamlAttribute_CsamlHorizontalAlignmentEnum_CsamlHorizontalAlignmentEnum_MIN;
  static const CsamlHorizontalAlignmentEnum CsamlHorizontalAlignmentEnum_MAX =
    CsamlAttribute_CsamlHorizontalAlignmentEnum_CsamlHorizontalAlignmentEnum_MAX;
  static const int CsamlHorizontalAlignmentEnum_ARRAYSIZE =
    CsamlAttribute_CsamlHorizontalAlignmentEnum_CsamlHorizontalAlignmentEnum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CsamlHorizontalAlignmentEnum_descriptor() {
    return CsamlAttribute_CsamlHorizontalAlignmentEnum_descriptor();
  }
  static inline const ::std::string& CsamlHorizontalAlignmentEnum_Name(CsamlHorizontalAlignmentEnum value) {
    return CsamlAttribute_CsamlHorizontalAlignmentEnum_Name(value);
  }
  static inline bool CsamlHorizontalAlignmentEnum_Parse(const ::std::string& name,
      CsamlHorizontalAlignmentEnum* value) {
    return CsamlAttribute_CsamlHorizontalAlignmentEnum_Parse(name, value);
  }
  
  typedef CsamlAttribute_CsamlVerticalAlignmentEnum CsamlVerticalAlignmentEnum;
  static const CsamlVerticalAlignmentEnum AlignTop = CsamlAttribute_CsamlVerticalAlignmentEnum_AlignTop;
  static const CsamlVerticalAlignmentEnum AlignCenterV = CsamlAttribute_CsamlVerticalAlignmentEnum_AlignCenterV;
  static const CsamlVerticalAlignmentEnum AlignBottom = CsamlAttribute_CsamlVerticalAlignmentEnum_AlignBottom;
  static inline bool CsamlVerticalAlignmentEnum_IsValid(int value) {
    return CsamlAttribute_CsamlVerticalAlignmentEnum_IsValid(value);
  }
  static const CsamlVerticalAlignmentEnum CsamlVerticalAlignmentEnum_MIN =
    CsamlAttribute_CsamlVerticalAlignmentEnum_CsamlVerticalAlignmentEnum_MIN;
  static const CsamlVerticalAlignmentEnum CsamlVerticalAlignmentEnum_MAX =
    CsamlAttribute_CsamlVerticalAlignmentEnum_CsamlVerticalAlignmentEnum_MAX;
  static const int CsamlVerticalAlignmentEnum_ARRAYSIZE =
    CsamlAttribute_CsamlVerticalAlignmentEnum_CsamlVerticalAlignmentEnum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CsamlVerticalAlignmentEnum_descriptor() {
    return CsamlAttribute_CsamlVerticalAlignmentEnum_descriptor();
  }
  static inline const ::std::string& CsamlVerticalAlignmentEnum_Name(CsamlVerticalAlignmentEnum value) {
    return CsamlAttribute_CsamlVerticalAlignmentEnum_Name(value);
  }
  static inline bool CsamlVerticalAlignmentEnum_Parse(const ::std::string& name,
      CsamlVerticalAlignmentEnum* value) {
    return CsamlAttribute_CsamlVerticalAlignmentEnum_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .resource.CsamlAttribute.CsamlAttributeType Type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::resource::CsamlAttribute_CsamlAttributeType type() const;
  inline void set_type(::resource::CsamlAttribute_CsamlAttributeType value);
  
  // required .resource.CsamlAttribute.CsamlAttributeValueType ValueType = 2 [default = String];
  inline bool has_valuetype() const;
  inline void clear_valuetype();
  static const int kValueTypeFieldNumber = 2;
  inline ::resource::CsamlAttribute_CsamlAttributeValueType valuetype() const;
  inline void set_valuetype(::resource::CsamlAttribute_CsamlAttributeValueType value);
  
  // optional string ValueString = 3;
  inline bool has_valuestring() const;
  inline void clear_valuestring();
  static const int kValueStringFieldNumber = 3;
  inline const ::std::string& valuestring() const;
  inline void set_valuestring(const ::std::string& value);
  inline void set_valuestring(const char* value);
  inline void set_valuestring(const char* value, size_t size);
  inline ::std::string* mutable_valuestring();
  inline ::std::string* release_valuestring();
  
  // optional int32 ValueInt = 4;
  inline bool has_valueint() const;
  inline void clear_valueint();
  static const int kValueIntFieldNumber = 4;
  inline ::google::protobuf::int32 valueint() const;
  inline void set_valueint(::google::protobuf::int32 value);
  
  // optional float ValueFloat = 5;
  inline bool has_valuefloat() const;
  inline void clear_valuefloat();
  static const int kValueFloatFieldNumber = 5;
  inline float valuefloat() const;
  inline void set_valuefloat(float value);
  
  // @@protoc_insertion_point(class_scope:resource.CsamlAttribute)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_valuetype();
  inline void clear_has_valuetype();
  inline void set_has_valuestring();
  inline void clear_has_valuestring();
  inline void set_has_valueint();
  inline void clear_has_valueint();
  inline void set_has_valuefloat();
  inline void clear_has_valuefloat();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int type_;
  int valuetype_;
  ::std::string* valuestring_;
  ::google::protobuf::int32 valueint_;
  float valuefloat_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_Protobuf_2fresource_2eproto();
  friend void protobuf_AssignDesc_Protobuf_2fresource_2eproto();
  friend void protobuf_ShutdownFile_Protobuf_2fresource_2eproto();
  
  void InitAsDefaultInstance();
  static CsamlAttribute* default_instance_;
};
// -------------------------------------------------------------------

class CsamlNode : public ::google::protobuf::Message {
 public:
  CsamlNode();
  virtual ~CsamlNode();
  
  CsamlNode(const CsamlNode& from);
  
  inline CsamlNode& operator=(const CsamlNode& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CsamlNode& default_instance();
  
  void Swap(CsamlNode* other);
  
  // implements Message ----------------------------------------------
  
  CsamlNode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CsamlNode& from);
  void MergeFrom(const CsamlNode& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef CsamlNode_CsamlNodeType CsamlNodeType;
  static const CsamlNodeType Unknown = CsamlNode_CsamlNodeType_Unknown;
  static const CsamlNodeType Frame = CsamlNode_CsamlNodeType_Frame;
  static const CsamlNodeType Image = CsamlNode_CsamlNodeType_Image;
  static const CsamlNodeType SolidText = CsamlNode_CsamlNodeType_SolidText;
  static const CsamlNodeType DynamicText = CsamlNode_CsamlNodeType_DynamicText;
  static const CsamlNodeType Console = CsamlNode_CsamlNodeType_Console;
  static const CsamlNodeType Page = CsamlNode_CsamlNodeType_Page;
  static inline bool CsamlNodeType_IsValid(int value) {
    return CsamlNode_CsamlNodeType_IsValid(value);
  }
  static const CsamlNodeType CsamlNodeType_MIN =
    CsamlNode_CsamlNodeType_CsamlNodeType_MIN;
  static const CsamlNodeType CsamlNodeType_MAX =
    CsamlNode_CsamlNodeType_CsamlNodeType_MAX;
  static const int CsamlNodeType_ARRAYSIZE =
    CsamlNode_CsamlNodeType_CsamlNodeType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CsamlNodeType_descriptor() {
    return CsamlNode_CsamlNodeType_descriptor();
  }
  static inline const ::std::string& CsamlNodeType_Name(CsamlNodeType value) {
    return CsamlNode_CsamlNodeType_Name(value);
  }
  static inline bool CsamlNodeType_Parse(const ::std::string& name,
      CsamlNodeType* value) {
    return CsamlNode_CsamlNodeType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .resource.CsamlNode.CsamlNodeType Type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::resource::CsamlNode_CsamlNodeType type() const;
  inline void set_type(::resource::CsamlNode_CsamlNodeType value);
  
  // repeated .resource.CsamlAttribute Attributes = 2;
  inline int attributes_size() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 2;
  inline const ::resource::CsamlAttribute& attributes(int index) const;
  inline ::resource::CsamlAttribute* mutable_attributes(int index);
  inline ::resource::CsamlAttribute* add_attributes();
  inline const ::google::protobuf::RepeatedPtrField< ::resource::CsamlAttribute >&
      attributes() const;
  inline ::google::protobuf::RepeatedPtrField< ::resource::CsamlAttribute >*
      mutable_attributes();
  
  // repeated .resource.CsamlNode Children = 3;
  inline int children_size() const;
  inline void clear_children();
  static const int kChildrenFieldNumber = 3;
  inline const ::resource::CsamlNode& children(int index) const;
  inline ::resource::CsamlNode* mutable_children(int index);
  inline ::resource::CsamlNode* add_children();
  inline const ::google::protobuf::RepeatedPtrField< ::resource::CsamlNode >&
      children() const;
  inline ::google::protobuf::RepeatedPtrField< ::resource::CsamlNode >*
      mutable_children();
  
  // @@protoc_insertion_point(class_scope:resource.CsamlNode)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::resource::CsamlAttribute > attributes_;
  ::google::protobuf::RepeatedPtrField< ::resource::CsamlNode > children_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Protobuf_2fresource_2eproto();
  friend void protobuf_AssignDesc_Protobuf_2fresource_2eproto();
  friend void protobuf_ShutdownFile_Protobuf_2fresource_2eproto();
  
  void InitAsDefaultInstance();
  static CsamlNode* default_instance_;
};
// -------------------------------------------------------------------

class Csaml : public ::google::protobuf::Message {
 public:
  Csaml();
  virtual ~Csaml();
  
  Csaml(const Csaml& from);
  
  inline Csaml& operator=(const Csaml& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Csaml& default_instance();
  
  void Swap(Csaml* other);
  
  // implements Message ----------------------------------------------
  
  Csaml* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Csaml& from);
  void MergeFrom(const Csaml& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .resource.CsamlNode Nodes = 1;
  inline int nodes_size() const;
  inline void clear_nodes();
  static const int kNodesFieldNumber = 1;
  inline const ::resource::CsamlNode& nodes(int index) const;
  inline ::resource::CsamlNode* mutable_nodes(int index);
  inline ::resource::CsamlNode* add_nodes();
  inline const ::google::protobuf::RepeatedPtrField< ::resource::CsamlNode >&
      nodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::resource::CsamlNode >*
      mutable_nodes();
  
  // @@protoc_insertion_point(class_scope:resource.Csaml)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::resource::CsamlNode > nodes_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Protobuf_2fresource_2eproto();
  friend void protobuf_AssignDesc_Protobuf_2fresource_2eproto();
  friend void protobuf_ShutdownFile_Protobuf_2fresource_2eproto();
  
  void InitAsDefaultInstance();
  static Csaml* default_instance_;
};
// -------------------------------------------------------------------

class UserInterface : public ::google::protobuf::Message {
 public:
  UserInterface();
  virtual ~UserInterface();
  
  UserInterface(const UserInterface& from);
  
  inline UserInterface& operator=(const UserInterface& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInterface& default_instance();
  
  void Swap(UserInterface* other);
  
  // implements Message ----------------------------------------------
  
  UserInterface* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserInterface& from);
  void MergeFrom(const UserInterface& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 Version = 1 [default = 1];
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);
  
  // required .resource.Csaml Csaml = 2;
  inline bool has_csaml() const;
  inline void clear_csaml();
  static const int kCsamlFieldNumber = 2;
  inline const ::resource::Csaml& csaml() const;
  inline ::resource::Csaml* mutable_csaml();
  inline ::resource::Csaml* release_csaml();
  
  // required .resource.Script Script = 3;
  inline bool has_script() const;
  inline void clear_script();
  static const int kScriptFieldNumber = 3;
  inline const ::resource::Script& script() const;
  inline ::resource::Script* mutable_script();
  inline ::resource::Script* release_script();
  
  // @@protoc_insertion_point(class_scope:resource.UserInterface)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_csaml();
  inline void clear_has_csaml();
  inline void set_has_script();
  inline void clear_has_script();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::resource::Csaml* csaml_;
  ::resource::Script* script_;
  ::google::protobuf::int32 version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Protobuf_2fresource_2eproto();
  friend void protobuf_AssignDesc_Protobuf_2fresource_2eproto();
  friend void protobuf_ShutdownFile_Protobuf_2fresource_2eproto();
  
  void InitAsDefaultInstance();
  static UserInterface* default_instance_;
};
// ===================================================================


// ===================================================================

// StoredMatrix

// repeated float Data = 1;
inline int StoredMatrix::data_size() const {
  return data_.size();
}
inline void StoredMatrix::clear_data() {
  data_.Clear();
}
inline float StoredMatrix::data(int index) const {
  return data_.Get(index);
}
inline void StoredMatrix::set_data(int index, float value) {
  data_.Set(index, value);
}
inline void StoredMatrix::add_data(float value) {
  data_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
StoredMatrix::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedField< float >*
StoredMatrix::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// Raw

// required bytes Data = 1;
inline bool Raw::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Raw::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Raw::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Raw::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& Raw::data() const {
  return *data_;
}
inline void Raw::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void Raw::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void Raw::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Raw::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* Raw::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// CompiledShader

// required int32 Version = 1 [default = 1];
inline bool CompiledShader::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CompiledShader::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CompiledShader::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CompiledShader::clear_version() {
  version_ = 1;
  clear_has_version();
}
inline ::google::protobuf::int32 CompiledShader::version() const {
  return version_;
}
inline void CompiledShader::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
}

// required bytes MD5 = 2;
inline bool CompiledShader::has_md5() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CompiledShader::set_has_md5() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CompiledShader::clear_has_md5() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CompiledShader::clear_md5() {
  if (md5_ != &::google::protobuf::internal::kEmptyString) {
    md5_->clear();
  }
  clear_has_md5();
}
inline const ::std::string& CompiledShader::md5() const {
  return *md5_;
}
inline void CompiledShader::set_md5(const ::std::string& value) {
  set_has_md5();
  if (md5_ == &::google::protobuf::internal::kEmptyString) {
    md5_ = new ::std::string;
  }
  md5_->assign(value);
}
inline void CompiledShader::set_md5(const char* value) {
  set_has_md5();
  if (md5_ == &::google::protobuf::internal::kEmptyString) {
    md5_ = new ::std::string;
  }
  md5_->assign(value);
}
inline void CompiledShader::set_md5(const void* value, size_t size) {
  set_has_md5();
  if (md5_ == &::google::protobuf::internal::kEmptyString) {
    md5_ = new ::std::string;
  }
  md5_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CompiledShader::mutable_md5() {
  set_has_md5();
  if (md5_ == &::google::protobuf::internal::kEmptyString) {
    md5_ = new ::std::string;
  }
  return md5_;
}
inline ::std::string* CompiledShader::release_md5() {
  clear_has_md5();
  if (md5_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = md5_;
    md5_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes Data = 3;
inline bool CompiledShader::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CompiledShader::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CompiledShader::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CompiledShader::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& CompiledShader::data() const {
  return *data_;
}
inline void CompiledShader::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void CompiledShader::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void CompiledShader::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CompiledShader::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* CompiledShader::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ModelElement

// repeated float Position = 1 [packed = true];
inline int ModelElement::position_size() const {
  return position_.size();
}
inline void ModelElement::clear_position() {
  position_.Clear();
}
inline float ModelElement::position(int index) const {
  return position_.Get(index);
}
inline void ModelElement::set_position(int index, float value) {
  position_.Set(index, value);
}
inline void ModelElement::add_position(float value) {
  position_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
ModelElement::position() const {
  return position_;
}
inline ::google::protobuf::RepeatedField< float >*
ModelElement::mutable_position() {
  return &position_;
}

// repeated float Normal = 2 [packed = true];
inline int ModelElement::normal_size() const {
  return normal_.size();
}
inline void ModelElement::clear_normal() {
  normal_.Clear();
}
inline float ModelElement::normal(int index) const {
  return normal_.Get(index);
}
inline void ModelElement::set_normal(int index, float value) {
  normal_.Set(index, value);
}
inline void ModelElement::add_normal(float value) {
  normal_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
ModelElement::normal() const {
  return normal_;
}
inline ::google::protobuf::RepeatedField< float >*
ModelElement::mutable_normal() {
  return &normal_;
}

// repeated float Texture = 3 [packed = true];
inline int ModelElement::texture_size() const {
  return texture_.size();
}
inline void ModelElement::clear_texture() {
  texture_.Clear();
}
inline float ModelElement::texture(int index) const {
  return texture_.Get(index);
}
inline void ModelElement::set_texture(int index, float value) {
  texture_.Set(index, value);
}
inline void ModelElement::add_texture(float value) {
  texture_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
ModelElement::texture() const {
  return texture_;
}
inline ::google::protobuf::RepeatedField< float >*
ModelElement::mutable_texture() {
  return &texture_;
}

// repeated float Tangent = 4 [packed = true];
inline int ModelElement::tangent_size() const {
  return tangent_.size();
}
inline void ModelElement::clear_tangent() {
  tangent_.Clear();
}
inline float ModelElement::tangent(int index) const {
  return tangent_.Get(index);
}
inline void ModelElement::set_tangent(int index, float value) {
  tangent_.Set(index, value);
}
inline void ModelElement::add_tangent(float value) {
  tangent_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
ModelElement::tangent() const {
  return tangent_;
}
inline ::google::protobuf::RepeatedField< float >*
ModelElement::mutable_tangent() {
  return &tangent_;
}

// -------------------------------------------------------------------

// ModelMaterial

// required .resource.ModelMaterial.ModelMaterialType Type = 1;
inline bool ModelMaterial::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModelMaterial::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModelMaterial::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModelMaterial::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::resource::ModelMaterial_ModelMaterialType ModelMaterial::type() const {
  return static_cast< ::resource::ModelMaterial_ModelMaterialType >(type_);
}
inline void ModelMaterial::set_type(::resource::ModelMaterial_ModelMaterialType value) {
  GOOGLE_DCHECK(::resource::ModelMaterial_ModelMaterialType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required string Name = 2;
inline bool ModelMaterial::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModelMaterial::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModelMaterial::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModelMaterial::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ModelMaterial::name() const {
  return *name_;
}
inline void ModelMaterial::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ModelMaterial::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ModelMaterial::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModelMaterial::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ModelMaterial::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string DiffuseTexture = 3;
inline bool ModelMaterial::has_diffusetexture() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModelMaterial::set_has_diffusetexture() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModelMaterial::clear_has_diffusetexture() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModelMaterial::clear_diffusetexture() {
  if (diffusetexture_ != &::google::protobuf::internal::kEmptyString) {
    diffusetexture_->clear();
  }
  clear_has_diffusetexture();
}
inline const ::std::string& ModelMaterial::diffusetexture() const {
  return *diffusetexture_;
}
inline void ModelMaterial::set_diffusetexture(const ::std::string& value) {
  set_has_diffusetexture();
  if (diffusetexture_ == &::google::protobuf::internal::kEmptyString) {
    diffusetexture_ = new ::std::string;
  }
  diffusetexture_->assign(value);
}
inline void ModelMaterial::set_diffusetexture(const char* value) {
  set_has_diffusetexture();
  if (diffusetexture_ == &::google::protobuf::internal::kEmptyString) {
    diffusetexture_ = new ::std::string;
  }
  diffusetexture_->assign(value);
}
inline void ModelMaterial::set_diffusetexture(const char* value, size_t size) {
  set_has_diffusetexture();
  if (diffusetexture_ == &::google::protobuf::internal::kEmptyString) {
    diffusetexture_ = new ::std::string;
  }
  diffusetexture_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModelMaterial::mutable_diffusetexture() {
  set_has_diffusetexture();
  if (diffusetexture_ == &::google::protobuf::internal::kEmptyString) {
    diffusetexture_ = new ::std::string;
  }
  return diffusetexture_;
}
inline ::std::string* ModelMaterial::release_diffusetexture() {
  clear_has_diffusetexture();
  if (diffusetexture_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = diffusetexture_;
    diffusetexture_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string NormalTexture = 4;
inline bool ModelMaterial::has_normaltexture() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ModelMaterial::set_has_normaltexture() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ModelMaterial::clear_has_normaltexture() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ModelMaterial::clear_normaltexture() {
  if (normaltexture_ != &::google::protobuf::internal::kEmptyString) {
    normaltexture_->clear();
  }
  clear_has_normaltexture();
}
inline const ::std::string& ModelMaterial::normaltexture() const {
  return *normaltexture_;
}
inline void ModelMaterial::set_normaltexture(const ::std::string& value) {
  set_has_normaltexture();
  if (normaltexture_ == &::google::protobuf::internal::kEmptyString) {
    normaltexture_ = new ::std::string;
  }
  normaltexture_->assign(value);
}
inline void ModelMaterial::set_normaltexture(const char* value) {
  set_has_normaltexture();
  if (normaltexture_ == &::google::protobuf::internal::kEmptyString) {
    normaltexture_ = new ::std::string;
  }
  normaltexture_->assign(value);
}
inline void ModelMaterial::set_normaltexture(const char* value, size_t size) {
  set_has_normaltexture();
  if (normaltexture_ == &::google::protobuf::internal::kEmptyString) {
    normaltexture_ = new ::std::string;
  }
  normaltexture_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModelMaterial::mutable_normaltexture() {
  set_has_normaltexture();
  if (normaltexture_ == &::google::protobuf::internal::kEmptyString) {
    normaltexture_ = new ::std::string;
  }
  return normaltexture_;
}
inline ::std::string* ModelMaterial::release_normaltexture() {
  clear_has_normaltexture();
  if (normaltexture_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = normaltexture_;
    normaltexture_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string AlphaTexture = 5;
inline bool ModelMaterial::has_alphatexture() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ModelMaterial::set_has_alphatexture() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ModelMaterial::clear_has_alphatexture() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ModelMaterial::clear_alphatexture() {
  if (alphatexture_ != &::google::protobuf::internal::kEmptyString) {
    alphatexture_->clear();
  }
  clear_has_alphatexture();
}
inline const ::std::string& ModelMaterial::alphatexture() const {
  return *alphatexture_;
}
inline void ModelMaterial::set_alphatexture(const ::std::string& value) {
  set_has_alphatexture();
  if (alphatexture_ == &::google::protobuf::internal::kEmptyString) {
    alphatexture_ = new ::std::string;
  }
  alphatexture_->assign(value);
}
inline void ModelMaterial::set_alphatexture(const char* value) {
  set_has_alphatexture();
  if (alphatexture_ == &::google::protobuf::internal::kEmptyString) {
    alphatexture_ = new ::std::string;
  }
  alphatexture_->assign(value);
}
inline void ModelMaterial::set_alphatexture(const char* value, size_t size) {
  set_has_alphatexture();
  if (alphatexture_ == &::google::protobuf::internal::kEmptyString) {
    alphatexture_ = new ::std::string;
  }
  alphatexture_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModelMaterial::mutable_alphatexture() {
  set_has_alphatexture();
  if (alphatexture_ == &::google::protobuf::internal::kEmptyString) {
    alphatexture_ = new ::std::string;
  }
  return alphatexture_;
}
inline ::std::string* ModelMaterial::release_alphatexture() {
  clear_has_alphatexture();
  if (alphatexture_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alphatexture_;
    alphatexture_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string SpecularTexture = 6;
inline bool ModelMaterial::has_speculartexture() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ModelMaterial::set_has_speculartexture() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ModelMaterial::clear_has_speculartexture() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ModelMaterial::clear_speculartexture() {
  if (speculartexture_ != &::google::protobuf::internal::kEmptyString) {
    speculartexture_->clear();
  }
  clear_has_speculartexture();
}
inline const ::std::string& ModelMaterial::speculartexture() const {
  return *speculartexture_;
}
inline void ModelMaterial::set_speculartexture(const ::std::string& value) {
  set_has_speculartexture();
  if (speculartexture_ == &::google::protobuf::internal::kEmptyString) {
    speculartexture_ = new ::std::string;
  }
  speculartexture_->assign(value);
}
inline void ModelMaterial::set_speculartexture(const char* value) {
  set_has_speculartexture();
  if (speculartexture_ == &::google::protobuf::internal::kEmptyString) {
    speculartexture_ = new ::std::string;
  }
  speculartexture_->assign(value);
}
inline void ModelMaterial::set_speculartexture(const char* value, size_t size) {
  set_has_speculartexture();
  if (speculartexture_ == &::google::protobuf::internal::kEmptyString) {
    speculartexture_ = new ::std::string;
  }
  speculartexture_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModelMaterial::mutable_speculartexture() {
  set_has_speculartexture();
  if (speculartexture_ == &::google::protobuf::internal::kEmptyString) {
    speculartexture_ = new ::std::string;
  }
  return speculartexture_;
}
inline ::std::string* ModelMaterial::release_speculartexture() {
  clear_has_speculartexture();
  if (speculartexture_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = speculartexture_;
    speculartexture_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required float Shinyness = 10;
inline bool ModelMaterial::has_shinyness() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ModelMaterial::set_has_shinyness() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ModelMaterial::clear_has_shinyness() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ModelMaterial::clear_shinyness() {
  shinyness_ = 0;
  clear_has_shinyness();
}
inline float ModelMaterial::shinyness() const {
  return shinyness_;
}
inline void ModelMaterial::set_shinyness(float value) {
  set_has_shinyness();
  shinyness_ = value;
}

// required float Refraction = 11;
inline bool ModelMaterial::has_refraction() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ModelMaterial::set_has_refraction() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ModelMaterial::clear_has_refraction() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ModelMaterial::clear_refraction() {
  refraction_ = 0;
  clear_has_refraction();
}
inline float ModelMaterial::refraction() const {
  return refraction_;
}
inline void ModelMaterial::set_refraction(float value) {
  set_has_refraction();
  refraction_ = value;
}

// optional float Transparancy = 12;
inline bool ModelMaterial::has_transparancy() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ModelMaterial::set_has_transparancy() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ModelMaterial::clear_has_transparancy() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ModelMaterial::clear_transparancy() {
  transparancy_ = 0;
  clear_has_transparancy();
}
inline float ModelMaterial::transparancy() const {
  return transparancy_;
}
inline void ModelMaterial::set_transparancy(float value) {
  set_has_transparancy();
  transparancy_ = value;
}

// repeated float ColorDiffuse = 20 [packed = true];
inline int ModelMaterial::colordiffuse_size() const {
  return colordiffuse_.size();
}
inline void ModelMaterial::clear_colordiffuse() {
  colordiffuse_.Clear();
}
inline float ModelMaterial::colordiffuse(int index) const {
  return colordiffuse_.Get(index);
}
inline void ModelMaterial::set_colordiffuse(int index, float value) {
  colordiffuse_.Set(index, value);
}
inline void ModelMaterial::add_colordiffuse(float value) {
  colordiffuse_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
ModelMaterial::colordiffuse() const {
  return colordiffuse_;
}
inline ::google::protobuf::RepeatedField< float >*
ModelMaterial::mutable_colordiffuse() {
  return &colordiffuse_;
}

// repeated float ColorSpecular = 21 [packed = true];
inline int ModelMaterial::colorspecular_size() const {
  return colorspecular_.size();
}
inline void ModelMaterial::clear_colorspecular() {
  colorspecular_.Clear();
}
inline float ModelMaterial::colorspecular(int index) const {
  return colorspecular_.Get(index);
}
inline void ModelMaterial::set_colorspecular(int index, float value) {
  colorspecular_.Set(index, value);
}
inline void ModelMaterial::add_colorspecular(float value) {
  colorspecular_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
ModelMaterial::colorspecular() const {
  return colorspecular_;
}
inline ::google::protobuf::RepeatedField< float >*
ModelMaterial::mutable_colorspecular() {
  return &colorspecular_;
}

// repeated float ColorEmission = 22 [packed = true];
inline int ModelMaterial::coloremission_size() const {
  return coloremission_.size();
}
inline void ModelMaterial::clear_coloremission() {
  coloremission_.Clear();
}
inline float ModelMaterial::coloremission(int index) const {
  return coloremission_.Get(index);
}
inline void ModelMaterial::set_coloremission(int index, float value) {
  coloremission_.Set(index, value);
}
inline void ModelMaterial::add_coloremission(float value) {
  coloremission_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
ModelMaterial::coloremission() const {
  return coloremission_;
}
inline ::google::protobuf::RepeatedField< float >*
ModelMaterial::mutable_coloremission() {
  return &coloremission_;
}

// repeated float ColorAmbient = 23 [packed = true];
inline int ModelMaterial::colorambient_size() const {
  return colorambient_.size();
}
inline void ModelMaterial::clear_colorambient() {
  colorambient_.Clear();
}
inline float ModelMaterial::colorambient(int index) const {
  return colorambient_.Get(index);
}
inline void ModelMaterial::set_colorambient(int index, float value) {
  colorambient_.Set(index, value);
}
inline void ModelMaterial::add_colorambient(float value) {
  colorambient_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
ModelMaterial::colorambient() const {
  return colorambient_;
}
inline ::google::protobuf::RepeatedField< float >*
ModelMaterial::mutable_colorambient() {
  return &colorambient_;
}

// -------------------------------------------------------------------

// Model

// required int32 Version = 1 [default = 1];
inline bool Model::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Model::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Model::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Model::clear_version() {
  version_ = 1;
  clear_has_version();
}
inline ::google::protobuf::int32 Model::version() const {
  return version_;
}
inline void Model::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
}

// required string Name = 2;
inline bool Model::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Model::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Model::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Model::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Model::name() const {
  return *name_;
}
inline void Model::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Model::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Model::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Model::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Model::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bool TangentsCalculated = 3 [default = false];
inline bool Model::has_tangentscalculated() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Model::set_has_tangentscalculated() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Model::clear_has_tangentscalculated() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Model::clear_tangentscalculated() {
  tangentscalculated_ = false;
  clear_has_tangentscalculated();
}
inline bool Model::tangentscalculated() const {
  return tangentscalculated_;
}
inline void Model::set_tangentscalculated(bool value) {
  set_has_tangentscalculated();
  tangentscalculated_ = value;
}

// repeated .resource.ModelElement Elements = 20;
inline int Model::elements_size() const {
  return elements_.size();
}
inline void Model::clear_elements() {
  elements_.Clear();
}
inline const ::resource::ModelElement& Model::elements(int index) const {
  return elements_.Get(index);
}
inline ::resource::ModelElement* Model::mutable_elements(int index) {
  return elements_.Mutable(index);
}
inline ::resource::ModelElement* Model::add_elements() {
  return elements_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::resource::ModelElement >&
Model::elements() const {
  return elements_;
}
inline ::google::protobuf::RepeatedPtrField< ::resource::ModelElement >*
Model::mutable_elements() {
  return &elements_;
}

// repeated .resource.ModelMaterial Materials = 21;
inline int Model::materials_size() const {
  return materials_.size();
}
inline void Model::clear_materials() {
  materials_.Clear();
}
inline const ::resource::ModelMaterial& Model::materials(int index) const {
  return materials_.Get(index);
}
inline ::resource::ModelMaterial* Model::mutable_materials(int index) {
  return materials_.Mutable(index);
}
inline ::resource::ModelMaterial* Model::add_materials() {
  return materials_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::resource::ModelMaterial >&
Model::materials() const {
  return materials_;
}
inline ::google::protobuf::RepeatedPtrField< ::resource::ModelMaterial >*
Model::mutable_materials() {
  return &materials_;
}

// repeated uint32 Indices = 22;
inline int Model::indices_size() const {
  return indices_.size();
}
inline void Model::clear_indices() {
  indices_.Clear();
}
inline ::google::protobuf::uint32 Model::indices(int index) const {
  return indices_.Get(index);
}
inline void Model::set_indices(int index, ::google::protobuf::uint32 value) {
  indices_.Set(index, value);
}
inline void Model::add_indices(::google::protobuf::uint32 value) {
  indices_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
Model::indices() const {
  return indices_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
Model::mutable_indices() {
  return &indices_;
}

// -------------------------------------------------------------------

// ModelGroup

// required int32 Version = 1 [default = 1];
inline bool ModelGroup::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModelGroup::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModelGroup::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModelGroup::clear_version() {
  version_ = 1;
  clear_has_version();
}
inline ::google::protobuf::int32 ModelGroup::version() const {
  return version_;
}
inline void ModelGroup::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
}

// required string Name = 2;
inline bool ModelGroup::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModelGroup::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModelGroup::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModelGroup::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ModelGroup::name() const {
  return *name_;
}
inline void ModelGroup::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ModelGroup::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ModelGroup::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModelGroup::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ModelGroup::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated float Offset = 10 [packed = true];
inline int ModelGroup::offset_size() const {
  return offset_.size();
}
inline void ModelGroup::clear_offset() {
  offset_.Clear();
}
inline float ModelGroup::offset(int index) const {
  return offset_.Get(index);
}
inline void ModelGroup::set_offset(int index, float value) {
  offset_.Set(index, value);
}
inline void ModelGroup::add_offset(float value) {
  offset_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
ModelGroup::offset() const {
  return offset_;
}
inline ::google::protobuf::RepeatedField< float >*
ModelGroup::mutable_offset() {
  return &offset_;
}

// repeated float Rotation = 11 [packed = true];
inline int ModelGroup::rotation_size() const {
  return rotation_.size();
}
inline void ModelGroup::clear_rotation() {
  rotation_.Clear();
}
inline float ModelGroup::rotation(int index) const {
  return rotation_.Get(index);
}
inline void ModelGroup::set_rotation(int index, float value) {
  rotation_.Set(index, value);
}
inline void ModelGroup::add_rotation(float value) {
  rotation_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
ModelGroup::rotation() const {
  return rotation_;
}
inline ::google::protobuf::RepeatedField< float >*
ModelGroup::mutable_rotation() {
  return &rotation_;
}

// repeated float Scale = 12 [packed = true];
inline int ModelGroup::scale_size() const {
  return scale_.size();
}
inline void ModelGroup::clear_scale() {
  scale_.Clear();
}
inline float ModelGroup::scale(int index) const {
  return scale_.Get(index);
}
inline void ModelGroup::set_scale(int index, float value) {
  scale_.Set(index, value);
}
inline void ModelGroup::add_scale(float value) {
  scale_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
ModelGroup::scale() const {
  return scale_;
}
inline ::google::protobuf::RepeatedField< float >*
ModelGroup::mutable_scale() {
  return &scale_;
}

// repeated .resource.Model Models = 20;
inline int ModelGroup::models_size() const {
  return models_.size();
}
inline void ModelGroup::clear_models() {
  models_.Clear();
}
inline const ::resource::Model& ModelGroup::models(int index) const {
  return models_.Get(index);
}
inline ::resource::Model* ModelGroup::mutable_models(int index) {
  return models_.Mutable(index);
}
inline ::resource::Model* ModelGroup::add_models() {
  return models_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::resource::Model >&
ModelGroup::models() const {
  return models_;
}
inline ::google::protobuf::RepeatedPtrField< ::resource::Model >*
ModelGroup::mutable_models() {
  return &models_;
}

// repeated .resource.ModelGroup Groups = 21;
inline int ModelGroup::groups_size() const {
  return groups_.size();
}
inline void ModelGroup::clear_groups() {
  groups_.Clear();
}
inline const ::resource::ModelGroup& ModelGroup::groups(int index) const {
  return groups_.Get(index);
}
inline ::resource::ModelGroup* ModelGroup::mutable_groups(int index) {
  return groups_.Mutable(index);
}
inline ::resource::ModelGroup* ModelGroup::add_groups() {
  return groups_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::resource::ModelGroup >&
ModelGroup::groups() const {
  return groups_;
}
inline ::google::protobuf::RepeatedPtrField< ::resource::ModelGroup >*
ModelGroup::mutable_groups() {
  return &groups_;
}

// repeated .resource.StoredMatrix Transformations = 22;
inline int ModelGroup::transformations_size() const {
  return transformations_.size();
}
inline void ModelGroup::clear_transformations() {
  transformations_.Clear();
}
inline const ::resource::StoredMatrix& ModelGroup::transformations(int index) const {
  return transformations_.Get(index);
}
inline ::resource::StoredMatrix* ModelGroup::mutable_transformations(int index) {
  return transformations_.Mutable(index);
}
inline ::resource::StoredMatrix* ModelGroup::add_transformations() {
  return transformations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::resource::StoredMatrix >&
ModelGroup::transformations() const {
  return transformations_;
}
inline ::google::protobuf::RepeatedPtrField< ::resource::StoredMatrix >*
ModelGroup::mutable_transformations() {
  return &transformations_;
}

// -------------------------------------------------------------------

// StageProperty

// required string Id = 1;
inline bool StageProperty::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StageProperty::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StageProperty::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StageProperty::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& StageProperty::id() const {
  return *id_;
}
inline void StageProperty::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void StageProperty::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void StageProperty::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StageProperty::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* StageProperty::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .resource.StageProperty.StagePropertyType Type = 2;
inline bool StageProperty::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StageProperty::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StageProperty::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StageProperty::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::resource::StageProperty_StagePropertyType StageProperty::type() const {
  return static_cast< ::resource::StageProperty_StagePropertyType >(type_);
}
inline void StageProperty::set_type(::resource::StageProperty_StagePropertyType value) {
  GOOGLE_DCHECK(::resource::StageProperty_StagePropertyType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required bytes Data = 3;
inline bool StageProperty::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StageProperty::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StageProperty::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StageProperty::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& StageProperty::data() const {
  return *data_;
}
inline void StageProperty::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void StageProperty::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void StageProperty::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StageProperty::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* StageProperty::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// StageCamera

// required string Id = 1;
inline bool StageCamera::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StageCamera::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StageCamera::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StageCamera::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& StageCamera::id() const {
  return *id_;
}
inline void StageCamera::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void StageCamera::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void StageCamera::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StageCamera::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* StageCamera::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required float FieldOfView = 2;
inline bool StageCamera::has_fieldofview() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StageCamera::set_has_fieldofview() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StageCamera::clear_has_fieldofview() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StageCamera::clear_fieldofview() {
  fieldofview_ = 0;
  clear_has_fieldofview();
}
inline float StageCamera::fieldofview() const {
  return fieldofview_;
}
inline void StageCamera::set_fieldofview(float value) {
  set_has_fieldofview();
  fieldofview_ = value;
}

// optional int32 LayerFlags = 10;
inline bool StageCamera::has_layerflags() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StageCamera::set_has_layerflags() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StageCamera::clear_has_layerflags() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StageCamera::clear_layerflags() {
  layerflags_ = 0;
  clear_has_layerflags();
}
inline ::google::protobuf::int32 StageCamera::layerflags() const {
  return layerflags_;
}
inline void StageCamera::set_layerflags(::google::protobuf::int32 value) {
  set_has_layerflags();
  layerflags_ = value;
}

// repeated .resource.StageProperty Properties = 11;
inline int StageCamera::properties_size() const {
  return properties_.size();
}
inline void StageCamera::clear_properties() {
  properties_.Clear();
}
inline const ::resource::StageProperty& StageCamera::properties(int index) const {
  return properties_.Get(index);
}
inline ::resource::StageProperty* StageCamera::mutable_properties(int index) {
  return properties_.Mutable(index);
}
inline ::resource::StageProperty* StageCamera::add_properties() {
  return properties_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::resource::StageProperty >&
StageCamera::properties() const {
  return properties_;
}
inline ::google::protobuf::RepeatedPtrField< ::resource::StageProperty >*
StageCamera::mutable_properties() {
  return &properties_;
}

// repeated float Position = 20 [packed = true];
inline int StageCamera::position_size() const {
  return position_.size();
}
inline void StageCamera::clear_position() {
  position_.Clear();
}
inline float StageCamera::position(int index) const {
  return position_.Get(index);
}
inline void StageCamera::set_position(int index, float value) {
  position_.Set(index, value);
}
inline void StageCamera::add_position(float value) {
  position_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
StageCamera::position() const {
  return position_;
}
inline ::google::protobuf::RepeatedField< float >*
StageCamera::mutable_position() {
  return &position_;
}

// repeated float Rotation = 21 [packed = true];
inline int StageCamera::rotation_size() const {
  return rotation_.size();
}
inline void StageCamera::clear_rotation() {
  rotation_.Clear();
}
inline float StageCamera::rotation(int index) const {
  return rotation_.Get(index);
}
inline void StageCamera::set_rotation(int index, float value) {
  rotation_.Set(index, value);
}
inline void StageCamera::add_rotation(float value) {
  rotation_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
StageCamera::rotation() const {
  return rotation_;
}
inline ::google::protobuf::RepeatedField< float >*
StageCamera::mutable_rotation() {
  return &rotation_;
}

// -------------------------------------------------------------------

// StageLight

// required string Id = 1;
inline bool StageLight::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StageLight::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StageLight::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StageLight::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& StageLight::id() const {
  return *id_;
}
inline void StageLight::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void StageLight::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void StageLight::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StageLight::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* StageLight::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .resource.StageLight.StageLightType Type = 2;
inline bool StageLight::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StageLight::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StageLight::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StageLight::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::resource::StageLight_StageLightType StageLight::type() const {
  return static_cast< ::resource::StageLight_StageLightType >(type_);
}
inline void StageLight::set_type(::resource::StageLight_StageLightType value) {
  GOOGLE_DCHECK(::resource::StageLight_StageLightType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional float Radius = 3;
inline bool StageLight::has_radius() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StageLight::set_has_radius() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StageLight::clear_has_radius() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StageLight::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline float StageLight::radius() const {
  return radius_;
}
inline void StageLight::set_radius(float value) {
  set_has_radius();
  radius_ = value;
}

// optional float Intensity = 4;
inline bool StageLight::has_intensity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StageLight::set_has_intensity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StageLight::clear_has_intensity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StageLight::clear_intensity() {
  intensity_ = 0;
  clear_has_intensity();
}
inline float StageLight::intensity() const {
  return intensity_;
}
inline void StageLight::set_intensity(float value) {
  set_has_intensity();
  intensity_ = value;
}

// optional float AmbientIntensity = 5;
inline bool StageLight::has_ambientintensity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StageLight::set_has_ambientintensity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StageLight::clear_has_ambientintensity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StageLight::clear_ambientintensity() {
  ambientintensity_ = 0;
  clear_has_ambientintensity();
}
inline float StageLight::ambientintensity() const {
  return ambientintensity_;
}
inline void StageLight::set_ambientintensity(float value) {
  set_has_ambientintensity();
  ambientintensity_ = value;
}

// optional float SpotSize = 6;
inline bool StageLight::has_spotsize() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StageLight::set_has_spotsize() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StageLight::clear_has_spotsize() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StageLight::clear_spotsize() {
  spotsize_ = 0;
  clear_has_spotsize();
}
inline float StageLight::spotsize() const {
  return spotsize_;
}
inline void StageLight::set_spotsize(float value) {
  set_has_spotsize();
  spotsize_ = value;
}

// optional float Angle = 7;
inline bool StageLight::has_angle() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void StageLight::set_has_angle() {
  _has_bits_[0] |= 0x00000040u;
}
inline void StageLight::clear_has_angle() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void StageLight::clear_angle() {
  angle_ = 0;
  clear_has_angle();
}
inline float StageLight::angle() const {
  return angle_;
}
inline void StageLight::set_angle(float value) {
  set_has_angle();
  angle_ = value;
}

// optional int32 LayerFlags = 10;
inline bool StageLight::has_layerflags() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void StageLight::set_has_layerflags() {
  _has_bits_[0] |= 0x00000080u;
}
inline void StageLight::clear_has_layerflags() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void StageLight::clear_layerflags() {
  layerflags_ = 0;
  clear_has_layerflags();
}
inline ::google::protobuf::int32 StageLight::layerflags() const {
  return layerflags_;
}
inline void StageLight::set_layerflags(::google::protobuf::int32 value) {
  set_has_layerflags();
  layerflags_ = value;
}

// repeated .resource.StageProperty Properties = 11;
inline int StageLight::properties_size() const {
  return properties_.size();
}
inline void StageLight::clear_properties() {
  properties_.Clear();
}
inline const ::resource::StageProperty& StageLight::properties(int index) const {
  return properties_.Get(index);
}
inline ::resource::StageProperty* StageLight::mutable_properties(int index) {
  return properties_.Mutable(index);
}
inline ::resource::StageProperty* StageLight::add_properties() {
  return properties_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::resource::StageProperty >&
StageLight::properties() const {
  return properties_;
}
inline ::google::protobuf::RepeatedPtrField< ::resource::StageProperty >*
StageLight::mutable_properties() {
  return &properties_;
}

// repeated float Location = 20 [packed = true];
inline int StageLight::location_size() const {
  return location_.size();
}
inline void StageLight::clear_location() {
  location_.Clear();
}
inline float StageLight::location(int index) const {
  return location_.Get(index);
}
inline void StageLight::set_location(int index, float value) {
  location_.Set(index, value);
}
inline void StageLight::add_location(float value) {
  location_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
StageLight::location() const {
  return location_;
}
inline ::google::protobuf::RepeatedField< float >*
StageLight::mutable_location() {
  return &location_;
}

// repeated float Direction = 21 [packed = true];
inline int StageLight::direction_size() const {
  return direction_.size();
}
inline void StageLight::clear_direction() {
  direction_.Clear();
}
inline float StageLight::direction(int index) const {
  return direction_.Get(index);
}
inline void StageLight::set_direction(int index, float value) {
  direction_.Set(index, value);
}
inline void StageLight::add_direction(float value) {
  direction_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
StageLight::direction() const {
  return direction_;
}
inline ::google::protobuf::RepeatedField< float >*
StageLight::mutable_direction() {
  return &direction_;
}

// repeated float Color = 22 [packed = true];
inline int StageLight::color_size() const {
  return color_.size();
}
inline void StageLight::clear_color() {
  color_.Clear();
}
inline float StageLight::color(int index) const {
  return color_.Get(index);
}
inline void StageLight::set_color(int index, float value) {
  color_.Set(index, value);
}
inline void StageLight::add_color(float value) {
  color_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
StageLight::color() const {
  return color_;
}
inline ::google::protobuf::RepeatedField< float >*
StageLight::mutable_color() {
  return &color_;
}

// -------------------------------------------------------------------

// StageModel

// required string Id = 1;
inline bool StageModel::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StageModel::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StageModel::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StageModel::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& StageModel::id() const {
  return *id_;
}
inline void StageModel::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void StageModel::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void StageModel::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StageModel::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* StageModel::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 ReferenceId = 2;
inline bool StageModel::has_referenceid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StageModel::set_has_referenceid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StageModel::clear_has_referenceid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StageModel::clear_referenceid() {
  referenceid_ = 0;
  clear_has_referenceid();
}
inline ::google::protobuf::int32 StageModel::referenceid() const {
  return referenceid_;
}
inline void StageModel::set_referenceid(::google::protobuf::int32 value) {
  set_has_referenceid();
  referenceid_ = value;
}

// optional int32 LayerFlags = 10;
inline bool StageModel::has_layerflags() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StageModel::set_has_layerflags() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StageModel::clear_has_layerflags() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StageModel::clear_layerflags() {
  layerflags_ = 0;
  clear_has_layerflags();
}
inline ::google::protobuf::int32 StageModel::layerflags() const {
  return layerflags_;
}
inline void StageModel::set_layerflags(::google::protobuf::int32 value) {
  set_has_layerflags();
  layerflags_ = value;
}

// repeated .resource.StageProperty Properties = 11;
inline int StageModel::properties_size() const {
  return properties_.size();
}
inline void StageModel::clear_properties() {
  properties_.Clear();
}
inline const ::resource::StageProperty& StageModel::properties(int index) const {
  return properties_.Get(index);
}
inline ::resource::StageProperty* StageModel::mutable_properties(int index) {
  return properties_.Mutable(index);
}
inline ::resource::StageProperty* StageModel::add_properties() {
  return properties_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::resource::StageProperty >&
StageModel::properties() const {
  return properties_;
}
inline ::google::protobuf::RepeatedPtrField< ::resource::StageProperty >*
StageModel::mutable_properties() {
  return &properties_;
}

// repeated float Translation = 20 [packed = true];
inline int StageModel::translation_size() const {
  return translation_.size();
}
inline void StageModel::clear_translation() {
  translation_.Clear();
}
inline float StageModel::translation(int index) const {
  return translation_.Get(index);
}
inline void StageModel::set_translation(int index, float value) {
  translation_.Set(index, value);
}
inline void StageModel::add_translation(float value) {
  translation_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
StageModel::translation() const {
  return translation_;
}
inline ::google::protobuf::RepeatedField< float >*
StageModel::mutable_translation() {
  return &translation_;
}

// repeated float Rotation = 21 [packed = true];
inline int StageModel::rotation_size() const {
  return rotation_.size();
}
inline void StageModel::clear_rotation() {
  rotation_.Clear();
}
inline float StageModel::rotation(int index) const {
  return rotation_.Get(index);
}
inline void StageModel::set_rotation(int index, float value) {
  rotation_.Set(index, value);
}
inline void StageModel::add_rotation(float value) {
  rotation_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
StageModel::rotation() const {
  return rotation_;
}
inline ::google::protobuf::RepeatedField< float >*
StageModel::mutable_rotation() {
  return &rotation_;
}

// repeated float Scale = 22 [packed = true];
inline int StageModel::scale_size() const {
  return scale_.size();
}
inline void StageModel::clear_scale() {
  scale_.Clear();
}
inline float StageModel::scale(int index) const {
  return scale_.Get(index);
}
inline void StageModel::set_scale(int index, float value) {
  scale_.Set(index, value);
}
inline void StageModel::add_scale(float value) {
  scale_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
StageModel::scale() const {
  return scale_;
}
inline ::google::protobuf::RepeatedField< float >*
StageModel::mutable_scale() {
  return &scale_;
}

// repeated .resource.StageModel Children = 30;
inline int StageModel::children_size() const {
  return children_.size();
}
inline void StageModel::clear_children() {
  children_.Clear();
}
inline const ::resource::StageModel& StageModel::children(int index) const {
  return children_.Get(index);
}
inline ::resource::StageModel* StageModel::mutable_children(int index) {
  return children_.Mutable(index);
}
inline ::resource::StageModel* StageModel::add_children() {
  return children_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::resource::StageModel >&
StageModel::children() const {
  return children_;
}
inline ::google::protobuf::RepeatedPtrField< ::resource::StageModel >*
StageModel::mutable_children() {
  return &children_;
}

// -------------------------------------------------------------------

// Stage

// required int32 Version = 1 [default = 1];
inline bool Stage::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Stage::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Stage::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Stage::clear_version() {
  version_ = 1;
  clear_has_version();
}
inline ::google::protobuf::int32 Stage::version() const {
  return version_;
}
inline void Stage::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
}

// repeated string References = 9;
inline int Stage::references_size() const {
  return references_.size();
}
inline void Stage::clear_references() {
  references_.Clear();
}
inline const ::std::string& Stage::references(int index) const {
  return references_.Get(index);
}
inline ::std::string* Stage::mutable_references(int index) {
  return references_.Mutable(index);
}
inline void Stage::set_references(int index, const ::std::string& value) {
  references_.Mutable(index)->assign(value);
}
inline void Stage::set_references(int index, const char* value) {
  references_.Mutable(index)->assign(value);
}
inline void Stage::set_references(int index, const char* value, size_t size) {
  references_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Stage::add_references() {
  return references_.Add();
}
inline void Stage::add_references(const ::std::string& value) {
  references_.Add()->assign(value);
}
inline void Stage::add_references(const char* value) {
  references_.Add()->assign(value);
}
inline void Stage::add_references(const char* value, size_t size) {
  references_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Stage::references() const {
  return references_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Stage::mutable_references() {
  return &references_;
}

// repeated .resource.StageCamera Cameras = 10;
inline int Stage::cameras_size() const {
  return cameras_.size();
}
inline void Stage::clear_cameras() {
  cameras_.Clear();
}
inline const ::resource::StageCamera& Stage::cameras(int index) const {
  return cameras_.Get(index);
}
inline ::resource::StageCamera* Stage::mutable_cameras(int index) {
  return cameras_.Mutable(index);
}
inline ::resource::StageCamera* Stage::add_cameras() {
  return cameras_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::resource::StageCamera >&
Stage::cameras() const {
  return cameras_;
}
inline ::google::protobuf::RepeatedPtrField< ::resource::StageCamera >*
Stage::mutable_cameras() {
  return &cameras_;
}

// repeated .resource.StageLight Lights = 11;
inline int Stage::lights_size() const {
  return lights_.size();
}
inline void Stage::clear_lights() {
  lights_.Clear();
}
inline const ::resource::StageLight& Stage::lights(int index) const {
  return lights_.Get(index);
}
inline ::resource::StageLight* Stage::mutable_lights(int index) {
  return lights_.Mutable(index);
}
inline ::resource::StageLight* Stage::add_lights() {
  return lights_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::resource::StageLight >&
Stage::lights() const {
  return lights_;
}
inline ::google::protobuf::RepeatedPtrField< ::resource::StageLight >*
Stage::mutable_lights() {
  return &lights_;
}

// repeated .resource.StageModel Models = 12;
inline int Stage::models_size() const {
  return models_.size();
}
inline void Stage::clear_models() {
  models_.Clear();
}
inline const ::resource::StageModel& Stage::models(int index) const {
  return models_.Get(index);
}
inline ::resource::StageModel* Stage::mutable_models(int index) {
  return models_.Mutable(index);
}
inline ::resource::StageModel* Stage::add_models() {
  return models_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::resource::StageModel >&
Stage::models() const {
  return models_;
}
inline ::google::protobuf::RepeatedPtrField< ::resource::StageModel >*
Stage::mutable_models() {
  return &models_;
}

// -------------------------------------------------------------------

// Script

// required int32 Version = 1 [default = 1];
inline bool Script::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Script::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Script::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Script::clear_version() {
  version_ = 1;
  clear_has_version();
}
inline ::google::protobuf::int32 Script::version() const {
  return version_;
}
inline void Script::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
}

// required bytes ScriptData = 2;
inline bool Script::has_scriptdata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Script::set_has_scriptdata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Script::clear_has_scriptdata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Script::clear_scriptdata() {
  if (scriptdata_ != &::google::protobuf::internal::kEmptyString) {
    scriptdata_->clear();
  }
  clear_has_scriptdata();
}
inline const ::std::string& Script::scriptdata() const {
  return *scriptdata_;
}
inline void Script::set_scriptdata(const ::std::string& value) {
  set_has_scriptdata();
  if (scriptdata_ == &::google::protobuf::internal::kEmptyString) {
    scriptdata_ = new ::std::string;
  }
  scriptdata_->assign(value);
}
inline void Script::set_scriptdata(const char* value) {
  set_has_scriptdata();
  if (scriptdata_ == &::google::protobuf::internal::kEmptyString) {
    scriptdata_ = new ::std::string;
  }
  scriptdata_->assign(value);
}
inline void Script::set_scriptdata(const void* value, size_t size) {
  set_has_scriptdata();
  if (scriptdata_ == &::google::protobuf::internal::kEmptyString) {
    scriptdata_ = new ::std::string;
  }
  scriptdata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Script::mutable_scriptdata() {
  set_has_scriptdata();
  if (scriptdata_ == &::google::protobuf::internal::kEmptyString) {
    scriptdata_ = new ::std::string;
  }
  return scriptdata_;
}
inline ::std::string* Script::release_scriptdata() {
  clear_has_scriptdata();
  if (scriptdata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = scriptdata_;
    scriptdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// CsamlAttribute

// required .resource.CsamlAttribute.CsamlAttributeType Type = 1;
inline bool CsamlAttribute::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CsamlAttribute::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CsamlAttribute::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CsamlAttribute::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::resource::CsamlAttribute_CsamlAttributeType CsamlAttribute::type() const {
  return static_cast< ::resource::CsamlAttribute_CsamlAttributeType >(type_);
}
inline void CsamlAttribute::set_type(::resource::CsamlAttribute_CsamlAttributeType value) {
  GOOGLE_DCHECK(::resource::CsamlAttribute_CsamlAttributeType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required .resource.CsamlAttribute.CsamlAttributeValueType ValueType = 2 [default = String];
inline bool CsamlAttribute::has_valuetype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CsamlAttribute::set_has_valuetype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CsamlAttribute::clear_has_valuetype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CsamlAttribute::clear_valuetype() {
  valuetype_ = 0;
  clear_has_valuetype();
}
inline ::resource::CsamlAttribute_CsamlAttributeValueType CsamlAttribute::valuetype() const {
  return static_cast< ::resource::CsamlAttribute_CsamlAttributeValueType >(valuetype_);
}
inline void CsamlAttribute::set_valuetype(::resource::CsamlAttribute_CsamlAttributeValueType value) {
  GOOGLE_DCHECK(::resource::CsamlAttribute_CsamlAttributeValueType_IsValid(value));
  set_has_valuetype();
  valuetype_ = value;
}

// optional string ValueString = 3;
inline bool CsamlAttribute::has_valuestring() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CsamlAttribute::set_has_valuestring() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CsamlAttribute::clear_has_valuestring() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CsamlAttribute::clear_valuestring() {
  if (valuestring_ != &::google::protobuf::internal::kEmptyString) {
    valuestring_->clear();
  }
  clear_has_valuestring();
}
inline const ::std::string& CsamlAttribute::valuestring() const {
  return *valuestring_;
}
inline void CsamlAttribute::set_valuestring(const ::std::string& value) {
  set_has_valuestring();
  if (valuestring_ == &::google::protobuf::internal::kEmptyString) {
    valuestring_ = new ::std::string;
  }
  valuestring_->assign(value);
}
inline void CsamlAttribute::set_valuestring(const char* value) {
  set_has_valuestring();
  if (valuestring_ == &::google::protobuf::internal::kEmptyString) {
    valuestring_ = new ::std::string;
  }
  valuestring_->assign(value);
}
inline void CsamlAttribute::set_valuestring(const char* value, size_t size) {
  set_has_valuestring();
  if (valuestring_ == &::google::protobuf::internal::kEmptyString) {
    valuestring_ = new ::std::string;
  }
  valuestring_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CsamlAttribute::mutable_valuestring() {
  set_has_valuestring();
  if (valuestring_ == &::google::protobuf::internal::kEmptyString) {
    valuestring_ = new ::std::string;
  }
  return valuestring_;
}
inline ::std::string* CsamlAttribute::release_valuestring() {
  clear_has_valuestring();
  if (valuestring_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = valuestring_;
    valuestring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 ValueInt = 4;
inline bool CsamlAttribute::has_valueint() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CsamlAttribute::set_has_valueint() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CsamlAttribute::clear_has_valueint() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CsamlAttribute::clear_valueint() {
  valueint_ = 0;
  clear_has_valueint();
}
inline ::google::protobuf::int32 CsamlAttribute::valueint() const {
  return valueint_;
}
inline void CsamlAttribute::set_valueint(::google::protobuf::int32 value) {
  set_has_valueint();
  valueint_ = value;
}

// optional float ValueFloat = 5;
inline bool CsamlAttribute::has_valuefloat() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CsamlAttribute::set_has_valuefloat() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CsamlAttribute::clear_has_valuefloat() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CsamlAttribute::clear_valuefloat() {
  valuefloat_ = 0;
  clear_has_valuefloat();
}
inline float CsamlAttribute::valuefloat() const {
  return valuefloat_;
}
inline void CsamlAttribute::set_valuefloat(float value) {
  set_has_valuefloat();
  valuefloat_ = value;
}

// -------------------------------------------------------------------

// CsamlNode

// required .resource.CsamlNode.CsamlNodeType Type = 1;
inline bool CsamlNode::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CsamlNode::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CsamlNode::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CsamlNode::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::resource::CsamlNode_CsamlNodeType CsamlNode::type() const {
  return static_cast< ::resource::CsamlNode_CsamlNodeType >(type_);
}
inline void CsamlNode::set_type(::resource::CsamlNode_CsamlNodeType value) {
  GOOGLE_DCHECK(::resource::CsamlNode_CsamlNodeType_IsValid(value));
  set_has_type();
  type_ = value;
}

// repeated .resource.CsamlAttribute Attributes = 2;
inline int CsamlNode::attributes_size() const {
  return attributes_.size();
}
inline void CsamlNode::clear_attributes() {
  attributes_.Clear();
}
inline const ::resource::CsamlAttribute& CsamlNode::attributes(int index) const {
  return attributes_.Get(index);
}
inline ::resource::CsamlAttribute* CsamlNode::mutable_attributes(int index) {
  return attributes_.Mutable(index);
}
inline ::resource::CsamlAttribute* CsamlNode::add_attributes() {
  return attributes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::resource::CsamlAttribute >&
CsamlNode::attributes() const {
  return attributes_;
}
inline ::google::protobuf::RepeatedPtrField< ::resource::CsamlAttribute >*
CsamlNode::mutable_attributes() {
  return &attributes_;
}

// repeated .resource.CsamlNode Children = 3;
inline int CsamlNode::children_size() const {
  return children_.size();
}
inline void CsamlNode::clear_children() {
  children_.Clear();
}
inline const ::resource::CsamlNode& CsamlNode::children(int index) const {
  return children_.Get(index);
}
inline ::resource::CsamlNode* CsamlNode::mutable_children(int index) {
  return children_.Mutable(index);
}
inline ::resource::CsamlNode* CsamlNode::add_children() {
  return children_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::resource::CsamlNode >&
CsamlNode::children() const {
  return children_;
}
inline ::google::protobuf::RepeatedPtrField< ::resource::CsamlNode >*
CsamlNode::mutable_children() {
  return &children_;
}

// -------------------------------------------------------------------

// Csaml

// repeated .resource.CsamlNode Nodes = 1;
inline int Csaml::nodes_size() const {
  return nodes_.size();
}
inline void Csaml::clear_nodes() {
  nodes_.Clear();
}
inline const ::resource::CsamlNode& Csaml::nodes(int index) const {
  return nodes_.Get(index);
}
inline ::resource::CsamlNode* Csaml::mutable_nodes(int index) {
  return nodes_.Mutable(index);
}
inline ::resource::CsamlNode* Csaml::add_nodes() {
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::resource::CsamlNode >&
Csaml::nodes() const {
  return nodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::resource::CsamlNode >*
Csaml::mutable_nodes() {
  return &nodes_;
}

// -------------------------------------------------------------------

// UserInterface

// required int32 Version = 1 [default = 1];
inline bool UserInterface::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInterface::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInterface::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInterface::clear_version() {
  version_ = 1;
  clear_has_version();
}
inline ::google::protobuf::int32 UserInterface::version() const {
  return version_;
}
inline void UserInterface::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
}

// required .resource.Csaml Csaml = 2;
inline bool UserInterface::has_csaml() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInterface::set_has_csaml() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInterface::clear_has_csaml() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInterface::clear_csaml() {
  if (csaml_ != NULL) csaml_->::resource::Csaml::Clear();
  clear_has_csaml();
}
inline const ::resource::Csaml& UserInterface::csaml() const {
  return csaml_ != NULL ? *csaml_ : *default_instance_->csaml_;
}
inline ::resource::Csaml* UserInterface::mutable_csaml() {
  set_has_csaml();
  if (csaml_ == NULL) csaml_ = new ::resource::Csaml;
  return csaml_;
}
inline ::resource::Csaml* UserInterface::release_csaml() {
  clear_has_csaml();
  ::resource::Csaml* temp = csaml_;
  csaml_ = NULL;
  return temp;
}

// required .resource.Script Script = 3;
inline bool UserInterface::has_script() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserInterface::set_has_script() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserInterface::clear_has_script() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserInterface::clear_script() {
  if (script_ != NULL) script_->::resource::Script::Clear();
  clear_has_script();
}
inline const ::resource::Script& UserInterface::script() const {
  return script_ != NULL ? *script_ : *default_instance_->script_;
}
inline ::resource::Script* UserInterface::mutable_script() {
  set_has_script();
  if (script_ == NULL) script_ = new ::resource::Script;
  return script_;
}
inline ::resource::Script* UserInterface::release_script() {
  clear_has_script();
  ::resource::Script* temp = script_;
  script_ = NULL;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace resource

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::resource::ModelMaterial_ModelMaterialType>() {
  return ::resource::ModelMaterial_ModelMaterialType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::resource::StageProperty_StagePropertyType>() {
  return ::resource::StageProperty_StagePropertyType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::resource::StageLight_StageLightType>() {
  return ::resource::StageLight_StageLightType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::resource::CsamlAttribute_CsamlAttributeType>() {
  return ::resource::CsamlAttribute_CsamlAttributeType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::resource::CsamlAttribute_CsamlAttributeValueType>() {
  return ::resource::CsamlAttribute_CsamlAttributeValueType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::resource::CsamlAttribute_CsamlLayoutMode>() {
  return ::resource::CsamlAttribute_CsamlLayoutMode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::resource::CsamlAttribute_CsamlControlSizingMode>() {
  return ::resource::CsamlAttribute_CsamlControlSizingMode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::resource::CsamlAttribute_CsamlHorizontalAlignmentEnum>() {
  return ::resource::CsamlAttribute_CsamlHorizontalAlignmentEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::resource::CsamlAttribute_CsamlVerticalAlignmentEnum>() {
  return ::resource::CsamlAttribute_CsamlVerticalAlignmentEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::resource::CsamlNode_CsamlNodeType>() {
  return ::resource::CsamlNode_CsamlNodeType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Protobuf_2fresource_2eproto__INCLUDED
